{"version":3,"sources":["app.js","bar_directive.js","controller.js","directive.js","knob_directive.js"],"names":["angular","module","directive","restrict","require","compile","elem","attr","scope","ngSliderCtrl","updateBar","offset","valueToPercent","low","lowKnob","size","high","highKnob","css","options","vertical","top","height","left","width","bar","registerBar","onStart","addClass","onChange","onEnd","removeClass","$observe","events","window","PointerEvent","navigator","MSPointerEnabled","forEach","event","bind","ev","preventDefault","stopPropagation","start","controller","$scope","$timeout","knobSort","a","b","a_val","ngModel","$modelValue","b_val","updateKnobs","knobs","sort","knob","Math","max","floor","min","ceiling","addBar","bars","push","removeBar","splice","updateBars","lowFn","index","highFn","length","numKnobs","registeredBars","currentKnobs","startOffsets","sliding","this","defaultOptions","precision","buffer","steps","addStepNumbers","stickiness","scale","val","continuous","ctrl","fix","value","knobSize","offsetHeight","offsetWidth","knobPercent","dimensions","sliderSize","percent","parseFloat","registerKnob","normalizeModel","normalized","indexOf","stepWidth","floorMod","ceilingMod","mod","toFixed","isNaN","$setViewValue","$$phase","$apply","update","enabled","$watch","on","disabled","isDefined","targetTouches","identifier","$document","$compile","$interpolate","isUndefined","cursorPosition","position","sliderOffset","touches","pageY","pageX","knobPosition","offsetTop","offsetLeft","prepend","startSymbol","endSymbol","offsetParent","isArray","cursorPos","map","onMove","i","onResize","moveEvents","cancelEvents","endEvents","msPointerEnabled","concat","changedTouches","$eval","ngDisabled","keys","drgSliderOptions","opts","extend","isObject","$on","$parse","ctrls","updateModel","assign","$parent","ngModelCtrl","$viewValue"],"mappings":"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","file":"drg-slider.min.js","sourcesContent":["angular.module('drg.slider', []);\n","angular.module( 'drg.slider' )\n    .directive( 'drgSliderBar', function () {\n        return {\n            restrict : 'EA',\n            require : '^drgSlider',\n            compile : function ( elem, attr ) {\n                return function ( scope, elem, attr, ngSliderCtrl ) {\n                    // set up the defaults\n                    scope.low = 0;\n                    scope.high = 0;\n                    scope.lowKnob = null;\n                    scope.highKnob = null;\n\n                    /**\n                     * keep the bar the correct size\n                     */\n                    function updateBar() {\n                        // get the bar's offset\n                        var offset = ngSliderCtrl.valueToPercent( scope.low, scope.lowKnob ? scope.lowKnob.elem : null, true );\n\n                        // compute the size of the bar\n                        var size = ngSliderCtrl.valueToPercent( scope.high, scope.highKnob ? scope.highKnob.elem : null, true ) - offset;\n\n                        // set the CSS\n                        if( ngSliderCtrl.options.vertical ) {\n                            elem.css( {\n                                top : offset + '%',\n                                height : size + '%'\n                            } );\n                        } else {\n                            elem.css( {\n                                left : offset + '%',\n                                width : size + '%'\n                            } );\n                        }\n                    }\n\n                    // register this bar with the slider\n                    var bar = ngSliderCtrl.registerBar( {\n                        elem : elem,\n                        scope : scope,\n                        onStart : function () {\n                            elem.addClass( 'active' );\n                        },\n                        onChange : function () {\n                            updateBar();\n                        },\n                        onEnd : function () {\n                            elem.removeClass( 'active' );\n                        }\n                    } );\n\n                    // watch the attributes for updates\n                    attr.$observe( 'low', function ( low ) {\n                        scope.low = low;\n                        updateBar();\n                    } );\n                    attr.$observe( 'high', function ( high ) {\n                        scope.high = high;\n                        updateBar();\n                    } );\n\n                    // set the default events\n                    var events = [ 'mousedown', 'touchstart' ];\n                    if ( window.PointerEvent ) {\n                        // the browser supports javascript Pointer Events (currently only IE11), use those\n                        events = [ 'pointerdown' ];\n                    } else if ( window.navigator.MSPointerEnabled ) {\n                        // the browser supports M$'s javascript Pointer Events (IE10), use those\n                        events = [ 'MSPointerDown' ]\n                    }\n\n                    // bind the start events\n                    angular.forEach( events, function ( event ) {\n                        elem.bind( event, function ( ev ) {\n                            ev.preventDefault();\n                            ev.stopPropagation();\n                            bar.start( ev );\n                        } );\n                    } );\n                }\n            }\n        }\n    } );","angular.module( 'drg.slider' )\n    .controller( 'SliderCtrl', function ( $scope, $timeout ) {\n\n        // keep track of the registered knobs\n        $scope.knobs = [];\n\n        // keep track of the bars that have been created\n        $scope.bars = [];\n\n        // store the bars registered\n        var registeredBars = [];\n\n        // we'll use this to tell which knob is currently being moved\n        $scope.currentKnobs = [];\n        $scope.startOffsets = [];\n        $scope.sliding = false;\n\n        // set the default options\n        this.defaultOptions = {\n            precision : 0,\n            buffer : 0,\n            steps : 0,\n            addStepNumbers : false,\n            stickiness : 3,\n            scale : function ( val ) {\n                return val;\n            },\n            continuous : false,\n            vertical : false\n        };\n        // reference the options locally to avoid any scoping issues\n        this.options = this.defaultOptions;\n\n        var ctrl = this;\n\n        function knobSort( a, b ) {\n            var a_val = a.ngModel.$modelValue;\n            var b_val = b.ngModel.$modelValue;\n            return a_val > b_val ? 1 : (b_val > a_val ? -1 : 0);\n        }\n\n        /**\n         * Sort the knobs by model value\n         */\n        function updateKnobs() {\n            $scope.knobs.sort( knobSort );\n            angular.forEach( $scope.knobs, function( knob ) {\n                knob.ngModel.$modelValue = Math.max( $scope.floor, Math.min( knob.ngModel.$modelValue, $scope.ceiling ) );\n            } );\n        }\n\n        /**\n         * Add a bar\n         */\n        function addBar() {\n            $scope.bars.push( {\n                low : function () {\n                    return 0;\n                },\n                high : function () {\n                    return 0;\n                }\n            } );\n        }\n\n        /**\n         * Remove a bar\n         */\n        function removeBar() {\n            $scope.bars.splice( 0, 1 );\n        }\n\n        /**\n         * Make sure the correct number of bars exist and all have the right data\n         */\n        function updateBars() {\n            // get the knob count\n            var numKnobs = $scope.knobs.length;\n\n            // add bars so we have one more bar than knobs\n            while ( $scope.bars.length < numKnobs + 1 ) {\n                addBar();\n            }\n\n            // remove bars so we have one more bar than knobs\n            while ( $scope.bars.length > numKnobs + 1 ) {\n                removeBar();\n            }\n\n            /**\n             * Isolate the index from the for loop below so the low value is always correct\n             * @param index {number}\n             * @returns {Function}\n             */\n            function lowFn( index ) {\n                /**\n                 * Get the low value for the bar\n                 * @returns {number}\n                 */\n                return function () {\n                    return index > 0 ? $scope.knobs[ index - 1 ].ngModel.$modelValue : $scope.floor;\n                }\n            }\n\n            /**\n             * Isolate the index from the for loop below so the high value is always correct\n             * @param index {number}\n             * @returns {Function}\n             */\n            function highFn( index ) {\n                /**\n                 * Get the high value for the bar\n                 * @returns {number}\n                 */\n                return function () {\n                    return index < $scope.knobs.length ? $scope.knobs[ index ].ngModel.$modelValue : $scope.ceiling;\n                }\n            }\n\n            // update the low and high values for the bars\n            angular.forEach( $scope.bars, function ( bar, b ) {\n                bar.low = lowFn( b );\n                bar.high = highFn( b );\n            } );\n\n            // update the knobs and fire the change callback for all registered bars\n            angular.forEach( registeredBars, function ( bar, index ) {\n                bar.scope.lowKnob = index > 0 ? $scope.knobs[ index - 1 ] : null;\n                bar.scope.highKnob = index < $scope.knobs.length ? $scope.knobs[ index ] : null;\n                bar.onChange && bar.onChange();\n            } );\n        }\n\n        /**\n         * Call this to refresh the slider\n         */\n        $scope.fix = function () {\n            updateKnobs();\n            updateBars();\n        };\n\n        /**\n         * Convert a value to the correct percentage for display purposes\n         * @param value {number}\n         * @param knob {angular.element}\n         * @param bar {boolean}\n         * @returns {number}\n         */\n        this.valueToPercent = function ( value, knob, bar ) {\n            // default the knob to a size of 0\n            var knobSize = 0;\n\n            if ( knob ) {\n                // we've been given a knob, get the size\n                knobSize = this.options.vertical ? knob[ 0 ].offsetHeight : knob[ 0 ].offsetWidth;\n            }\n\n            // compute the percentage size of the knob\n            var knobPercent = knobSize / $scope.dimensions().sliderSize * 100;\n\n            // compute the percent offset of the knob taking into account he size of the knob\n            var percent = ( ( ( parseFloat( value ) - $scope.floor ) / ( $scope.ceiling - $scope.floor ) ) * ( 100 - knobPercent ) );\n\n            if ( bar && knob ) {\n                // we're computing this for a bar and we've been given a knob, add half of the knob back to keep the bar in the middle of the knob\n                percent += knobPercent / 2;\n            }\n\n            return percent;\n        };\n\n        /**\n         * Add the knob to the slider and return some useful functions\n         * @param knob {object}\n         * @returns {{start: start, disabled: disabled}}\n         */\n        this.registerKnob = function ( knob ) {\n\n            // is this knob enabled?\n            var enabled = true;\n\n            // add the knob to the list\n            $scope.knobs.push( knob );\n\n            /**\n             * Normalize the value so it adheres to these criteria:\n             *    - within bounds of the slider\n             *    - if not continuous, previous and next knobs are <= or >=, respectively\n             *    - if > 1 step, falls on a step\n             *    - has the given decimal precision\n             * Then fire this knob's onChange callback if the normalized value is the same as the given value\n             * @param value {number}\n             */\n            function normalizeModel( value ) {\n\n                // initialize the bounds\n                var ceiling = $scope.ceiling;\n                var floor = $scope.floor;\n\n                // start with the original value\n                var normalized = parseFloat( value );\n\n                // get the index of the knob so we know the surrounding knobs\n                var index = $scope.knobs.indexOf( knob );\n\n                if ( !ctrl.options.continuous ) {\n                    // keep the knobs contained to their section of the slider\n\n                    if ( index > 0 ) {\n                        // this isn't the knob with the lowest value, set the floor to the value of the knob lower than this\n                        floor = parseFloat( $scope.knobs[ index - 1 ].ngModel.$modelValue ) + (ctrl.options.buffer > 0 ? ctrl.options.buffer : 0);\n                    }\n                    if ( index < $scope.knobs.length - 1 ) {\n                        // this isn't the knob with the highest value, set the ceiling to the value of the knob higher than this\n                        ceiling = parseFloat( $scope.knobs[ index + 1 ].ngModel.$modelValue ) - (ctrl.options.buffer > 0 ? ctrl.options.buffer : 0);\n                    }\n                }\n\n                if ( ctrl.options.steps > 1 ) {\n                    // there should be more than one step\n\n                    // get the width of a step\n                    var stepWidth = ($scope.ceiling - $scope.floor) / (ctrl.options.steps - 1);\n\n                    if ( index > 0 ) {\n                        // this isn't the knob with the lowest value, make sure the floor aligns with a step\n                        var floorMod = (floor - $scope.floor) % stepWidth;\n                        if ( floorMod > 0 ) {\n                            floor += stepWidth - floorMod;\n                        }\n                    }\n\n                    if ( index < $scope.knobs.length - 1 ) {\n                        // this isn't the knob with the highest value, make sure the ceiling aligns with a step\n                        var ceilingMod = (ceiling - $scope.floor) % stepWidth;\n                        if ( ceilingMod > 0 ) {\n                            ceiling -= ceilingMod;\n                        }\n                    }\n\n                    // align the value with a step\n                    var mod = (normalized - $scope.floor) % stepWidth;\n                    if ( mod < stepWidth / 2 ) {\n                        normalized -= mod;\n                    } else {\n                        normalized += stepWidth - mod;\n                    }\n                }\n\n                // ensure the value is within the bounds\n                normalized = Math.min( ceiling, Math.max( normalized, floor ) );\n\n                if ( ctrl.options.precision >= 0 ) {\n                    // format the value to the correct decimal precision\n                    normalized = parseFloat( normalized.toFixed( ctrl.options.precision ) );\n                }\n\n                if ( normalized === value ) {\n                    // the normalized value is the same as the original, fire the onChange callback for this knob\n                    knob.onChange && knob.onChange( value );\n                } else if ( !isNaN( normalized ) ) {\n                    // the normalized value is different than the original (an it's a number), update the model\n                    knob.ngModel.$setViewValue( normalized );\n                    if ( !$scope.$$phase ) {\n                        $scope.$apply();\n                    }\n                }\n            }\n\n            /**\n             * Do what's needed to update the DOM\n             * @param value\n             */\n            function update( value ) {\n                if ( enabled ) {\n                    // normalize\n                    normalizeModel( value );\n\n                    // fix the DOM\n                    $scope.fix();\n\n                    // make sure the changes are digested\n                    if ( !$scope.$$phase ) {\n                        $scope.$apply();\n                    }\n                }\n            }\n\n            // watch this knob's model for changes\n            $scope.$watch( function () {\n                return knob.ngModel.$modelValue;\n            }, function ( value ) {\n                update( value );\n            } );\n\n            // watch for updates on the slider and update accordingly\n            //$scope.$watch( 'floor', function () {\n            //    update( knob.ngModel.$modelValue );\n            //} );\n            //$scope.$watch( 'ceiling', function () {\n            //    update( knob.ngModel.$modelValue );\n            //} );\n            $scope.$watch( function () {\n                return ctrl.options;\n            }, function () {\n                update( knob.ngModel.$modelValue );\n            }, true );\n\n            // initialize the bars\n            updateBars();\n\n            // listen for when this knob is removed from the DOM, remove it from the list and set to disabled\n            knob.elem.on( '$destroy', function () {\n                $scope.knobs.splice( $scope.knobs.indexOf( knob ), 1 );\n                enabled = false;\n            } );\n\n            // give the knob some useful functions\n            return {\n                start : function ( ev ) {\n                    if ( !$scope.disabled ) {\n                        if ( angular.isDefined( ev.targetTouches ) ) {\n                            $scope.currentKnobs[ ev.targetTouches[ 0 ].identifier ] = [ knob ];\n                        } else {\n                            $scope.currentKnobs[ 0 ] = [ knob ];\n                        }\n                        $scope.sliding = true;\n                        $scope.onStart( ev );\n                        knob.onStart();\n                    }\n                },\n                disabled : function () {\n                    var index = $scope.currentKnobs.indexOf( knob );\n                    if ( $scope.sliding && index >= 0 ) {\n                        $scope.onEnd( index );\n                    }\n                }\n            }\n        };\n\n        /**\n         * Add the bar to the slider\n         * @param bar {object}\n         * @return {{start: start}}\n         */\n        this.registerBar = function ( bar ) {\n            // add the bar to the list\n            registeredBars.push( bar );\n\n            // listen for when this bar is removed from the DOM and remove it from the list\n            bar.elem.on( '$destroy', function () {\n                var index = registeredBars.indexOf( bar );\n                if ( index >= 0 ) {\n                    registeredBars.splice( index, 1 );\n                }\n            } );\n\n            return {\n                start : function ( ev ) {\n                    if ( !$scope.disabled ) {\n                        var knobs = [];\n                        if ( bar.scope.lowKnob ) {\n                            knobs.push( bar.scope.lowKnob );\n                        }\n                        if ( bar.scope.highKnob ) {\n                            knobs.push( bar.scope.highKnob );\n                        }\n                        if ( angular.isDefined( ev.targetTouches ) ) {\n                            $scope.currentKnobs[ ev.targetTouches[ 0 ].identifier ] = knobs;\n                        } else {\n                            $scope.currentKnobs[ 0 ] = knobs;\n                        }\n                        $scope.sliding = true;\n                        $scope.onStart( ev );\n                        bar.onStart();\n                    }\n                }\n            }\n        }\n    } );\n","angular.module( 'drg.slider' )\n    .directive( 'drgSlider', function ( $document, $compile, $interpolate ) {\n        return {\n            restrict : 'EA',\n            controller : 'SliderCtrl',\n            scope : true,\n            compile : function ( elem, attr ) {\n                // check requirements\n                if ( angular.isUndefined( attr.floor ) ) {\n                    throw \"ngSlider Error: Floor not specified\";\n                }\n                if ( angular.isUndefined( attr.ceiling ) ) {\n                    throw \"ngSlider Error: Ceiling not specified\";\n                }\n\n                return function ( scope, elem, attr, ctrl ) {\n\n                    /**\n                     * Get the current relative position of the cursor at the given index\n                     * @param ev {Event}\n                     * @param index {number}\n                     * @returns {number}\n                     */\n                    function cursorPosition( ev, index ) {\n                        var position = -1 * scope.dimensions().sliderOffset;\n                        if ( ctrl.options.vertical ) {\n                            position += ev.touches ? ev.touches[ index ].pageY : ev.pageY;\n                        } else {\n                            position += ev.touches ? ev.touches[ index ].pageX : ev.pageX;\n                        }\n                        return position;\n                    }\n\n                    /**\n                     * Get the current position of the given knob\n                     * @param knob {angular.element}\n                     * @returns {number}\n                     */\n                    function knobPosition( knob ) {\n                        var offset = ctrl.options.vertical ? knob[ 0 ].offsetTop : knob[ 0 ].offsetLeft;\n                        return offset - scope.dimensions().sliderOffset;\n                    }\n\n                    // add the bars\n                    elem.prepend( $compile( '<drg-slider-bar low=\"' + $interpolate.startSymbol() + ' bar.low() ' + $interpolate.endSymbol() + '\" high=\"' + $interpolate.startSymbol() + ' bar.high() ' + $interpolate.endSymbol() + '\" ng-repeat=\"bar in bars\"></ng-slider-bar>' )( scope ) );\n\n                    /**\n                     * Get the current slider size and offset\n                     * @returns {{sliderSize: number, sliderOffset: number}}\n                     */\n                    scope.dimensions = function () {\n                        // get the offset for the slider\n                        var offset = ctrl.options.vertical ? elem[ 0 ].offsetTop : elem[ 0 ].offsetLeft;\n\n                        if ( elem[ 0 ].offsetParent ) {\n                            // take into account the offset of this element's parent\n                            offset += ctrl.options.vertical ? elem[ 0 ].offsetParent.offsetTop : elem[ 0 ].offsetParent.offsetLeft;\n                        }\n\n                        return {\n                            sliderSize : ctrl.options.vertical ? elem[ 0 ].offsetHeight : elem[ 0 ].offsetWidth,\t// get the size of the slider\n                            sliderOffset : offset\n                        };\n                    };\n\n                    /**\n                     * What to do when the user starts sliding\n                     * @param ev {Event}\n                     */\n                    scope.onStart = function ( ev ) {\n                        // get the index of the touch/mouse\n                        var index = 0;\n                        if ( ev.targetTouches ) {\n                            index = ev.targetTouches[ 0 ].identifier;\n                        }\n\n                        // save the starting position(s)\n                        if ( angular.isArray( scope.currentKnobs[ index ] ) && scope.currentKnobs[ index ].length > 1 ) {\n                            var cursorPos = cursorPosition( ev, index );\n                            scope.startOffsets[ index ] = scope.currentKnobs[ index ].map( function ( knob ) {\n                                return knobPosition( knob.elem ) - cursorPos;\n                            } );\n                        } else {\n                            scope.startOffsets[ index ] = [ 0 ];\n                        }\n\n                        // fire a \"move\"\n                        scope.onMove( ev );\n                    };\n\n                    /**\n                     * What to do when a knob is moved\n                     * @param ev {Event}\n                     */\n                    scope.onMove = function ( ev ) {\n                        // get the current dimensions\n                        var dimensions = scope.dimensions();\n\n                        angular.forEach( scope.currentKnobs, function ( knobs, index ) {\n                            if ( scope.currentKnobs[ index ] ) {\n                                // get the current mouse position\n                                var position = cursorPosition( ev, index );\n\n                                var startOffsets = scope.startOffsets[ index ];\n\n                                if ( !angular.isArray( knobs ) ) {\n                                    knobs = [ knobs ];\n                                }\n\n                                // get the size of the knob(s) being dragged\n                                for ( var i = 0; i < knobs.length; i++ ) {\n                                    // get the size of the knob\n                                    var knobSize = ctrl.options.vertical ? knobs[ i ].elem[ 0 ].offsetHeight : knobs[ i ].elem[ 0 ].offsetWidth;\n\n                                    // get the current mouse/finger position as a percentage\n                                    var percent = Math.max( 0, Math.min( (position + startOffsets[ i ] - (knobSize / 2)) / (dimensions.sliderSize - knobSize), 1 ) );\n\n                                    // compute the value from the percentage\n                                    var value = ((percent * (scope.ceiling - scope.floor)) + scope.floor).toFixed( ctrl.options.precision );\n\n                                    // update the model for the knob being dragged\n                                    knobs[ i ].ngModel.$setViewValue( value );\n                                    if ( !scope.$$phase ) {\n                                        scope.$apply();\n                                    }\n                                }\n                            }\n                        } );\n                    };\n\n                    /**\n                     * What to do when the slide is finished\n                     */\n                    scope.onEnd = function ( index ) {\n                        // remove the knob from the list of knobs currently being dragged\n                        var knobs = scope.currentKnobs[ index ] || [];\n                        if( index < scope.currentKnobs.length ) {\n                            delete scope.currentKnobs[ index ];\n                        }\n\n                        if ( !angular.isArray( knobs ) ) {\n                            knobs = [ knobs ];\n                        }\n\n                        angular.forEach( knobs, function ( knob ) {\n                            // fire the knob's onEnd callback\n                            knob.onEnd();\n                        } );\n\n                        if ( scope.currentKnobs.length == 0 ) {\n                            // we're no longer sliding\n                            scope.sliding = false;\n                        }\n                    };\n\n                    scope.onResize = function() {\n                        scope.fix();\n                    };\n\n                    // set the default events\n                    var moveEvents = [ 'mousemove', 'touchmove' ];\n                    var cancelEvents = [ 'mousecancel', 'touchcancel' ];\n                    var endEvents = [ 'mouseup', 'touchend' ];\n\n                    if ( window.PointerEvent ) {\n                        // the browser supports javascript Pointer Events (currently only IE11), use those\n                        moveEvents = [ 'pointermove' ];\n                        cancelEvents = [ 'pointercancel' ];\n                        endEvents = [ 'pointerup' ];\n                    } else if ( window.navigator.msPointerEnabled ) {\n                        // the browser supports M$'s javascript Pointer Events (IE10), use those\n                        moveEvents = [ 'MSPointerMove' ];\n                        cancelEvents = [ 'MSPointerCancel' ];\n                        endEvents = [ 'MSPointerUp' ];\n                    }\n\n                    // bind the move events\n                    angular.forEach( moveEvents, function ( event ) {\n                        $document.bind( event, function ( ev ) {\n                            if ( scope.sliding ) {\n                                // they see me slidin', they hatin'\n                                ev.preventDefault();\n                                ev.stopPropagation();\n                                scope.onMove( ev );\n                            }\n                        } );\n                    } );\n\n                    // bind the end and cancel events\n                    angular.forEach( cancelEvents.concat( endEvents ), function ( event ) {\n                        $document.bind( event, function ( ev ) {\n                            if ( scope.sliding ) {\n                                // it's electric, boogie woogie, woogie\n\n                                // fire the end events for the drags that are ending\n                                if ( ev.changedTouches ) {\n                                    for ( var i = 0; i < ev.changedTouches.length; i++ ) {\n                                        scope.onEnd( ev.changedTouches[ i ].identifier );\n                                    }\n                                } else {\n                                    scope.onEnd( 0 );\n                                }\n                            }\n                        } );\n                    } );\n\n                    // watch for disabilities\n                    scope.$watch( function () {\n                        return scope.$eval( attr.ngDisabled );\n                    }, function ( disabled ) {\n                        // do we have disabilities?\n                        scope.disabled = angular.isDefined( disabled ) && disabled;\n\n                        // tell the DOM\n                        if ( scope.disabled ) {\n                            elem.addClass( 'disabled' );\n                        } else {\n                            elem.removeClass( 'disabled' );\n                        }\n\n                        if ( scope.sliding ) {\n                            // I wanna wake up where you are, I won't say anything at all\n                            angular.forEach( scope.currentKnobs.keys(), function ( index ) {\n                                scope.onEnd( index );\n                            } );\n                        }\n                    } );\n\n                    // watch the attributes and update as necessary\n                    attr.$observe( 'ceiling', function ( ceiling ) {\n                        ceiling = angular.isDefined( ceiling ) ? parseFloat( ceiling ) : 0;\n                        scope.ceiling = isNaN( ceiling ) ? 0 : ceiling;\n                        scope.onResize();\n                    } );\n                    attr.$observe( 'floor', function ( floor ) {\n                        floor = angular.isDefined( floor ) ? parseFloat( floor ) : 0;\n                        scope.floor = isNaN( floor ) ? 0 : floor;\n                        scope.onResize();\n                    } );\n                    scope.$watch( function () {\n                        return scope.$eval( attr.drgSliderOptions );\n                    }, function ( opts ) {\n                        ctrl.options = angular.extend( {}, ctrl.defaultOptions, angular.isDefined( opts ) && angular.isObject( opts ) ? opts : {} );\n                        if ( ctrl.options.vertical ) {\n                            elem.addClass( 'drg-slider-vertical' ).removeClass( 'drg-slider-horizontal' );\n                        } else {\n                            elem.addClass( 'drg-slider-horizontal' ).removeClass( 'drg-slider-vertical' );\n                        }\n                    }, true );\n\n                    scope.$on( 'drgSlider.resize', scope.onResize );\n                };\n            }\n        }\n    } );\n","angular.module( 'drg.slider' )\n    .directive( 'drgSliderKnob', function ( $parse ) {\n        return {\n            restrict : 'EA',\n            require : [ '^drgSlider', '^ngModel' ],\n            scope : true,\n            compile : function ( elem, attr ) {\n                // make sure we have a model\n                if ( angular.isUndefined( attr.ngModel ) ) {\n                    throw \"ngSliderKnob Error: ngModel not specified\";\n                }\n\n                return function ( scope, elem, attr, ctrls ) {\n                    // get the controllers\n                    var ngSliderCtrl = ctrls[ 0 ];\n                    var ngModelCtrl = ctrls[ 1 ];\n\n                    // is the knob enabled?\n                    scope.enabled = true;\n\n                    /**\n                     * Make sure the value gets applied up the hierarchy\n                     * @param value {number}\n                     */\n                    function updateModel( value ) {\n                        $parse( attr.ngModel ).assign( scope.$parent.$parent, parseFloat( value ) );\n                        if ( !scope.$$phase ) {\n                            scope.$apply();\n                        }\n                    }\n\n                    // register the knob\n                    var knob = ngSliderCtrl.registerKnob( {\n                        ngModel : ngModelCtrl,\t\t\t// the model\n                        elem : elem,\t\t\t\t\t\t// the knob DOM element\n                        onChange : function ( value ) {\t\t// what to do when the model changes\n                            // sync the model\n                            updateModel( value );\n\n                            // expose the value to the scope\n                            scope.$viewValue = value;\n\n                            // set the CSS as needed\n                            elem.css( ngSliderCtrl.options.vertical ? 'top' : 'left', ngSliderCtrl.valueToPercent( value, elem ) + '%' );\n                        },\n                        onStart : function () {\t\t\t// what to do when the user starts dragging this knob\n                            elem.addClass( 'active' );\n                        },\n                        onEnd : function () {\t\t\t\t// what to do when the user stops dragging this knob\n                            elem.removeClass( 'active' );\n                        }\n                    } );\n\n                    // watch for disabilities\n                    scope.$watch( function () {\n                        return scope.$eval( attr.ngDisabled );\n                    }, function ( disabled ) {\n                        // is the knob disabled?\n                        scope.enabled = !disabled;\n\n                        // tell the DOM\n                        if ( disabled ) {\n                            elem.addClass( 'disabled' );\n                        } else {\n                            elem.removeClass( 'disabled' );\n                        }\n\n                        // tell the slider this knob is disabled\n                        scope.enabled || knob.disabled()\n                    } );\n\n                    // set the default events\n                    var events = [ 'mousedown', 'touchstart' ];\n                    if ( window.PointerEvent ) {\n                        // the browser supports javascript Pointer Events (currently only IE11), use those\n                        events = [ 'pointerdown' ];\n                    } else if ( window.navigator.MSPointerEnabled ) {\n                        // the browser supports M$'s javascript Pointer Events (IE10), use those\n                        events = [ 'MSPointerDown' ]\n                    }\n\n                    // bind the start events\n                    angular.forEach( events, function ( event ) {\n                        elem.bind( event, function ( ev ) {\n                            ev.preventDefault();\n                            ev.stopPropagation();\n                            knob.start( ev );\n                        } );\n                    } );\n                };\n            }\n        }\n    } );"],"sourceRoot":"/source/"}