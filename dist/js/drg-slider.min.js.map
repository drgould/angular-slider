{"version":3,"sources":["app.js","bar_directive.js","controller.js","directive.js","knob_directive.js"],"names":["angular","module","directive","restrict","require","compile","elem","attr","scope","ngSliderCtrl","updateBar","offset","valueToPercent","low","lowKnob","size","high","highKnob","css","options","vertical","top","height","left","width","bar","registerBar","onStart","addClass","onChange","onEnd","removeClass","$observe","events","window","PointerEvent","navigator","MSPointerEnabled","forEach","event","bind","ev","preventDefault","stopPropagation","start","controller","$scope","$timeout","knobSort","a","b","a_val","ngModel","$modelValue","b_val","sortKnobs","knobs","sort","updateKnobs","knob","Math","max","floor","min","ceiling","addBar","bars","push","removeBar","splice","updateBars","lowFn","index","highFn","length","numKnobs","registeredBars","nearestValue","position","undefined","arguments","isValue","values","ctrl","isEqualSpacing","percent","round","i","_this","this","SPACING_EQUAL","SPACING_RELATIVE","currentKnobs","startOffsets","sliding","defaultOptions","precision","buffer","steps","spacing","continuous","fixDebounce","fix","cancel","value","knobSize","offsetHeight","offsetWidth","knobPercent","dimensions","sliderSize","parseFloat","useValues","percentToValue","toPercent","registerKnob","normalizeModel","normalized","indexOf","stepWidth","floorMod","ceilingMod","mod","toFixed","isNaN","$setViewValue","$$phase","$apply","update","enabled","$watch","on","disabled","isDefined","targetTouches","identifier","isRelativeSpacing","$document","$compile","$interpolate","link","cursorPosition","sliderOffset","touches","pageY","pageX","knobPosition","offsetTop","offsetLeft","prepend","startSymbol","endSymbol","offsetParent","isArray","cursorPos","map","onMove","onResize","moveEvents","cancelEvents","endEvents","msPointerEnabled","concat","changedTouches","$eval","ngDisabled","keys","drgSliderOptions","opts","extend","isObject","$on","$parse","isUndefined","ctrls","updateModel","assign","$parent","ngModelCtrl","$viewValue"],"mappings":"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","file":"drg-slider.min.js","sourcesContent":["/**\n * angular-slider\n * @version 1.0.0-alpha.1\n * @copyright Derek Gould 2015\n * @license MIT\n */\nangular.module('drg.slider', []);\n","angular.module( 'drg.slider' )\n    .directive( 'drgSliderBar', function () {\n        return {\n            restrict : 'EA',\n            require : '^drgSlider',\n            compile : function ( elem, attr ) {\n                return function ( scope, elem, attr, ngSliderCtrl ) {\n                    // set up the defaults\n                    scope.low = 0;\n                    scope.high = 0;\n                    scope.lowKnob = null;\n                    scope.highKnob = null;\n\n                    /**\n                     * keep the bar the correct size\n                     */\n                    function updateBar() {\n                        // get the bar's offset\n                        var offset = ngSliderCtrl.valueToPercent( scope.low, scope.lowKnob ? scope.lowKnob.elem : null, true );\n\n                        // compute the size of the bar\n                        var size = ngSliderCtrl.valueToPercent( scope.high, scope.highKnob ? scope.highKnob.elem : null, true ) - offset;\n\n                        // set the CSS\n                        if( ngSliderCtrl.options.vertical ) {\n                            elem.css( {\n                                top : offset + '%',\n                                height : size + '%'\n                            } );\n                        } else {\n                            elem.css( {\n                                left : offset + '%',\n                                width : size + '%'\n                            } );\n                        }\n                    }\n\n                    // register this bar with the slider\n                    var bar = ngSliderCtrl.registerBar( {\n                        elem : elem,\n                        scope : scope,\n                        onStart : function () {\n                            elem.addClass( 'active' );\n                        },\n                        onChange : function () {\n                            updateBar();\n                        },\n                        onEnd : function () {\n                            elem.removeClass( 'active' );\n                        }\n                    } );\n\n                    // watch the attributes for updates\n                    attr.$observe( 'low', function ( low ) {\n                        scope.low = low;\n                        updateBar();\n                    } );\n                    attr.$observe( 'high', function ( high ) {\n                        scope.high = high;\n                        updateBar();\n                    } );\n\n                    // set the default events\n                    var events = [ 'mousedown', 'touchstart' ];\n                    if ( window.PointerEvent ) {\n                        // the browser supports javascript Pointer Events (currently only IE11), use those\n                        events = [ 'pointerdown' ];\n                    } else if ( window.navigator.MSPointerEnabled ) {\n                        // the browser supports M$'s javascript Pointer Events (IE10), use those\n                        events = [ 'MSPointerDown' ]\n                    }\n\n                    // bind the start events\n                    angular.forEach( events, function ( event ) {\n                        elem.bind( event, function ( ev ) {\n                            ev.preventDefault();\n                            ev.stopPropagation();\n                            bar.start( ev );\n                        } );\n                    } );\n                }\n            }\n        }\n    } );","angular.module( 'drg.slider' )\n    .controller( 'SliderCtrl', function ( $scope, $timeout ) {\n\n        var SPACING_EQUAL = 'equal';\n        var SPACING_RELATIVE = 'relative';\n\n        // keep track of the registered knobs\n        $scope.knobs = [];\n\n        // keep track of the bars that have been created\n        $scope.bars = [];\n\n        // store the bars registered\n        var registeredBars = [];\n\n        // we'll use this to tell which knob is currently being moved\n        $scope.currentKnobs = [];\n        $scope.startOffsets = [];\n        $scope.sliding = false;\n\n        // set the default options\n        this.defaultOptions = {\n            precision : 0,\n            buffer : 0,\n            steps : 0,\n            values : [],\n            spacing : SPACING_RELATIVE, // how to space the notches on the slider \"relative\" or \"equal\"\n            continuous : false,\n            vertical : false\n        };\n        // reference the options locally to avoid any scoping issues\n        this.options = this.defaultOptions;\n\n        var ctrl = this;\n\n        function knobSort( a, b ) {\n            var a_val = a.ngModel.$modelValue;\n            var b_val = b.ngModel.$modelValue;\n            return a_val > b_val ? 1 : (b_val > a_val ? -1 : 0);\n        }\n\n        function sortKnobs() {\n            console.log( 'sortKnobs' );\n            $scope.knobs.sort( knobSort );\n        }\n\n        /**\n         * Sort the knobs by model value\n         */\n        function updateKnobs() {\n            sortKnobs();\n            angular.forEach( $scope.knobs, function ( knob ) {\n                knob.ngModel.$modelValue = Math.max( $scope.floor, Math.min( knob.ngModel.$modelValue, $scope.ceiling ) );\n            } );\n        }\n\n        /**\n         * Add a bar\n         */\n        function addBar() {\n            $scope.bars.push( {\n                low : function () {\n                    return 0;\n                },\n                high : function () {\n                    return 0;\n                }\n            } );\n        }\n\n        /**\n         * Remove a bar\n         */\n        function removeBar() {\n            $scope.bars.splice( 0, 1 );\n        }\n\n        /**\n         * Make sure the correct number of bars exist and all have the right data\n         */\n        function updateBars() {\n            // get the knob count\n            var numKnobs = $scope.knobs.length;\n\n            // add bars so we have one more bar than knobs\n            while ( $scope.bars.length < numKnobs + 1 ) {\n                addBar();\n            }\n\n            // remove bars so we have one more bar than knobs\n            while ( $scope.bars.length > numKnobs + 1 ) {\n                removeBar();\n            }\n\n            /**\n             * Isolate the index from the for loop below so the low value is always correct\n             * @param index {number}\n             * @returns {Function}\n             */\n            function lowFn( index ) {\n                /**\n                 * Get the low value for the bar\n                 * @returns {number}\n                 */\n                return function () {\n                    return index > 0 ? $scope.knobs[ index - 1 ].ngModel.$modelValue : $scope.floor;\n                }\n            }\n\n            /**\n             * Isolate the index from the for loop below so the high value is always correct\n             * @param index {number}\n             * @returns {Function}\n             */\n            function highFn( index ) {\n                /**\n                 * Get the high value for the bar\n                 * @returns {number}\n                 */\n                return function () {\n                    return index < $scope.knobs.length ? $scope.knobs[ index ].ngModel.$modelValue : $scope.ceiling;\n                }\n            }\n\n            // update the low and high values for the bars\n            angular.forEach( $scope.bars, function ( bar, b ) {\n                bar.low = lowFn( b );\n                bar.high = highFn( b );\n            } );\n\n            // update the knobs and fire the change callback for all registered bars\n            angular.forEach( registeredBars, function ( bar, index ) {\n                bar.scope.lowKnob = index > 0 ? $scope.knobs[ index - 1 ] : null;\n                bar.scope.highKnob = index < $scope.knobs.length ? $scope.knobs[ index ] : null;\n                bar.onChange && bar.onChange();\n            } );\n        }\n\n        var fixDebounce;\n\n        /**\n         * Call this to refresh the slider\n         */\n        $scope.fix = function () {\n            $timeout.cancel( fixDebounce );\n            fixDebounce = $timeout( function() {\n                updateKnobs();\n                updateBars();\n            }, 25 );\n        };\n\n        /**\n         * Find the nearest value in the list of values\n         * @param position {number}\n         * @param [floor] {number}\n         * @param [ceiling] {number}\n         * @param [isValue] {boolean}\n         * @param [values] {number[]}\n         * @returns {number|undefined}\n         */\n        function nearestValue( position, floor=$scope.floor, ceiling=$scope.ceiling, isValue=false, values=ctrl.options.values ) {\n            if( ctrl.isEqualSpacing() && !isValue ) {\n                // using equal spacing strategy\n                var percent = ( position - $scope.floor ) / ( $scope.ceiling - $scope.floor );\n                var index = Math.round( percent * ( values.length - 1 ) );\n\n                while( index >= 0 && index < values.length ) {\n                    if( values[ index ] < floor ) {\n                        if( values[ index + 1 ] > ceiling ) {\n                            console.warn( 'Raise your roof!', position, values[ index ], values[ index + 1 ], ceiling );\n                            return undefined;\n                        }\n                        index++;\n                    } else if( values[ index ] > ceiling ) {\n                        if( values[ index - 1 ] < floor ) {\n                            console.warn( 'You\\'re giving me vertigo!', position, values[ index - 1 ], values[ index ], floor );\n                            return undefined;\n                        }\n                        index--;\n                    } else {\n                        return values[ index ];\n                    }\n                }\n\n                console.warn( 'I don\\'t fit anywhere :(', position, $scope.knobs.map( knob => knob.ngModel.$modelValue ), values, floor, ceiling );\n                return undefined;\n            }\n\n            // using relative spacing strategy\n            for( var i = 0; i < values.length - 1; i++ ) {\n                // find where the value fits in\n                if( position >= values[ i ] && position <= values[ i + 1 ]  ) {\n                    if( values[ i ] < floor && values[ i + 1 ] > ceiling ) {\n                        console.warn( 'BOONDOGGLE!', position, values[ i ], values[ i + 1 ], floor, ceiling );\n                        return undefined;\n                    } else if( values[ i ] < floor ) {\n                        console.debug( 'below floor', values[ i + 1 ] );\n                        return values[ i + 1 ];\n                    } else if( values[ i + 1 ] > ceiling ) {\n                        console.debug( 'above ceiling', values[ i ] );\n                        return values[ i ];\n                    }\n\n                    // and return the nearest value\n                    return values[ i + Math.round( ( position - values[ i ] ) / ( values[ i + 1 ] - values[ i ] ) ) ];\n                }\n            }\n\n            if( values[ values.length - 1 ] > ceiling ) {\n                console.warn( 'Tsk tsk!', position, values[ values.length - 1 ], ceiling );\n                return undefined;\n            }\n            // the value doesn't fit anywhere so just return the max value\n            return values[ values.length - 1 ];\n        }\n\n        /**\n         * Convert a value to the correct percentage for display purposes\n         * @param value {number}\n         * @param knob {angular.element}\n         * @param bar {boolean}\n         * @returns {number}\n         */\n        this.valueToPercent = function ( value, knob, bar ) {\n            // default the knob to a size of 0\n            var knobSize = 0;\n\n            if ( knob ) {\n                // we've been given a knob, get the size\n                knobSize = this.options.vertical ? knob[ 0 ].offsetHeight : knob[ 0 ].offsetWidth;\n            }\n\n            // compute the percentage size of the knob\n            var knobPercent = knobSize / $scope.dimensions().sliderSize * 100;\n\n            var percent = 1;\n\n            value = parseFloat( value );\n\n            if( ctrl.useValues() ) {\n                var values = ctrl.options.values;\n\n                for ( var i = 0; i < values.length - 1; i++ ) {\n                    // find where the value fits in\n                    if ( value >= values[ i ] && value <= values[ i + 1 ] ) {\n                        // and compute the relative percent\n                        var index = i + Math.round( ( value - values[ i ] ) / ( values[ i + 1 ] - values[ i ] ) );\n                        if( ctrl.isEqualSpacing() ) {\n                            percent = index / ( values.length - 1 );\n                        } else {\n                            percent = ( values[ index ] - $scope.floor ) / ( $scope.ceiling - $scope.floor );\n                        }\n                    }\n                }\n            } else {\n                percent = ( value - $scope.floor ) / ( $scope.ceiling - $scope.floor );\n            }\n\n            // compute the percent offset of the knob taking into account the size of the knob\n            percent = percent * ( 100 - knobPercent );\n\n            if ( bar && knob ) {\n                // we're computing this for a bar and we've been given a knob, add half of the knob back to keep the bar in the middle of the knob\n                percent += knobPercent / 2;\n            }\n\n            return percent;\n        };\n\n        /**\n         * Convert a percentage to a value\n         * @param percent {number}\n         * @param [floor] {number}\n         * @param [ceiling] {number}\n         * @returns {number}\n         */\n        this.percentToValue = function ( percent, floor=$scope.floor, ceiling=$scope.ceiling ) {\n            // compute the relative value\n            var value = ( percent * ( ceiling - floor ) ) + floor;\n\n            if( ctrl.useValues() ) {\n                // we have some specific values\n                return nearestValue( value, floor, ceiling );\n            }\n\n            // no specific values have been specified so just return the relative value\n            return value;\n        };\n\n        /**\n         * Compute the percent from the given value\n         * @param value {number}\n         * @returns {number}\n         */\n        this.toPercent = function( value ) {\n            return ( value - $scope.floor ) / ( $scope.ceiling - $scope.floor );\n        };\n\n        /**\n         * Add the knob to the slider and return some useful functions\n         * @param knob {object}\n         * @returns {{start: start, disabled: disabled}}\n         */\n        this.registerKnob = function ( knob ) {\n\n            // is this knob enabled?\n            var enabled = true;\n\n            // add the knob to the list\n            $scope.knobs.push( knob );\n            sortKnobs();\n\n            /**\n             * Normalize the value so it adheres to these criteria:\n             *    - within bounds of the slider\n             *    - if not continuous, previous and next knobs are <= or >=, respectively\n             *    - if > 1 step, falls on a step\n             *    - has the given decimal precision\n             * Then fire this knob's onChange callback if the normalized value is the same as the given value\n             * @param value {number}\n             */\n            function normalizeModel( value ) {\n                sortKnobs();\n\n                // initialize the bounds\n                var ceiling = $scope.ceiling;\n                var floor = $scope.floor;\n\n                // start with the original value\n                var normalized = parseFloat( value );\n\n                // get the index of the knob so we know the surrounding knobs\n                var index = $scope.knobs.indexOf( knob );\n\n                if ( !ctrl.options.continuous ) {\n                    // keep the knobs contained to their section of the slider\n\n                    if ( index > 0 ) {\n                        // this isn't the knob with the lowest value, set the floor to the value of the knob lower than this\n                        floor = parseFloat( $scope.knobs[ index - 1 ].ngModel.$modelValue ) + (ctrl.options.buffer > 0 ? ctrl.options.buffer : 0);\n                    }\n                    if ( index < $scope.knobs.length - 1 ) {\n                        // this isn't the knob with the highest value, set the ceiling to the value of the knob higher than this\n                        ceiling = parseFloat( $scope.knobs[ index + 1 ].ngModel.$modelValue ) - (ctrl.options.buffer > 0 ? ctrl.options.buffer : 0);\n                    }\n                }\n\n                if( ctrl.useValues() ) {\n                    // a specific set of values has been specified\n                    normalized = nearestValue( value, floor, ceiling, true );\n                } else if ( ctrl.options.steps > 1 ) {\n                    // there should be more than one step\n\n                    // get the width of a step\n                    var stepWidth = ($scope.ceiling - $scope.floor) / (ctrl.options.steps - 1);\n\n                    if ( index > 0 ) {\n                        // this isn't the knob with the lowest value, make sure the floor aligns with a step\n                        var floorMod = (floor - $scope.floor) % stepWidth;\n                        if ( floorMod > 0 ) {\n                            floor += stepWidth - floorMod;\n                        }\n                    }\n\n                    if ( index < $scope.knobs.length - 1 ) {\n                        // this isn't the knob with the highest value, make sure the ceiling aligns with a step\n                        var ceilingMod = (ceiling - $scope.floor) % stepWidth;\n                        if ( ceilingMod > 0 ) {\n                            ceiling -= ceilingMod;\n                        }\n                    }\n\n                    // align the value with a step\n                    var mod = (normalized - $scope.floor) % stepWidth;\n                    if ( mod < stepWidth / 2 ) {\n                        normalized -= mod;\n                    } else {\n                        normalized += stepWidth - mod;\n                    }\n                }\n\n                // ensure the value is within the bounds\n                normalized = Math.min( ceiling, Math.max( normalized, floor ) );\n\n                if ( ctrl.options.precision >= 0 ) {\n                    // format the value to the correct decimal precision\n                    normalized = parseFloat( normalized.toFixed( ctrl.options.precision ) );\n                }\n\n                if ( normalized === value ) {\n                    // the normalized value is the same as the original, fire the onChange callback for this knob\n                    knob.onChange && knob.onChange( value );\n                } else if ( !isNaN( normalized ) ) {\n                    // the normalized value is different than the original (an it's a number), update the model\n                    knob.ngModel.$setViewValue( normalized );\n                    if ( !$scope.$$phase ) {\n                        $scope.$apply();\n                    }\n                }\n            }\n\n            /**\n             * Do what's needed to update the DOM\n             * @param value\n             */\n            function update( value ) {\n                if ( enabled ) {\n                    // normalize\n                    normalizeModel( value );\n\n                    // fix the DOM\n                    $scope.fix();\n\n                    // make sure the changes are digested\n                    if ( !$scope.$$phase ) {\n                        $scope.$apply();\n                    }\n                }\n            }\n\n            // watch this knob's model for changes\n            $scope.$watch( function () {\n                return knob.ngModel.$modelValue;\n            }, function ( value ) {\n                update( value );\n            } );\n\n            $scope.$watch( function () {\n                return ctrl.options;\n            }, function () {\n                update( knob.ngModel.$modelValue );\n            }, true );\n\n            // initialize the bars\n            updateBars();\n\n            // listen for when this knob is removed from the DOM, remove it from the list and set to disabled\n            knob.elem.on( '$destroy', function () {\n                $scope.knobs.splice( $scope.knobs.indexOf( knob ), 1 );\n                enabled = false;\n            } );\n\n            // give the knob some useful functions\n            return {\n                start : function ( ev ) {\n                    if ( !$scope.disabled ) {\n                        if ( angular.isDefined( ev.targetTouches ) ) {\n                            $scope.currentKnobs[ ev.targetTouches[ 0 ].identifier ] = [ knob ];\n                        } else {\n                            $scope.currentKnobs[ 0 ] = [ knob ];\n                        }\n                        $scope.sliding = true;\n                        $scope.onStart( ev );\n                        knob.onStart();\n                    }\n                },\n                disabled : function () {\n                    var index = $scope.currentKnobs.indexOf( knob );\n                    if ( $scope.sliding && index >= 0 ) {\n                        $scope.onEnd( index );\n                    }\n                }\n            }\n        };\n\n        /**\n         * Add the bar to the slider\n         * @param bar {object}\n         * @return {{start: start}}\n         */\n        this.registerBar = function ( bar ) {\n            // add the bar to the list\n            registeredBars.push( bar );\n\n            // listen for when this bar is removed from the DOM and remove it from the list\n            bar.elem.on( '$destroy', function () {\n                var index = registeredBars.indexOf( bar );\n                if ( index >= 0 ) {\n                    registeredBars.splice( index, 1 );\n                }\n            } );\n\n            return {\n                start : function ( ev ) {\n                    if ( !$scope.disabled ) {\n                        var knobs = [];\n                        if ( bar.scope.lowKnob ) {\n                            knobs.push( bar.scope.lowKnob );\n                        }\n                        if ( bar.scope.highKnob ) {\n                            knobs.push( bar.scope.highKnob );\n                        }\n                        if ( angular.isDefined( ev.targetTouches ) ) {\n                            $scope.currentKnobs[ ev.targetTouches[ 0 ].identifier ] = knobs;\n                        } else {\n                            $scope.currentKnobs[ 0 ] = knobs;\n                        }\n                        $scope.sliding = true;\n                        $scope.onStart( ev );\n                        bar.onStart();\n                    }\n                }\n            }\n        };\n\n        this.isEqualSpacing = () => this.options.spacing === SPACING_EQUAL;\n        this.isRelativeSpacing = () => this.options.spacing === SPACING_RELATIVE;\n\n        this.useValues = () => ctrl.options.values.length > 1;\n    } );\n","angular.module( 'drg.slider' )\n    .directive( 'drgSlider', function ( $document, $compile, $interpolate ) {\n        return {\n            restrict : 'EA',\n            controller : 'SliderCtrl',\n            scope : true,\n            link : function ( scope, elem, attr, ctrl ) {\n\n                /**\n                 * Get the current relative position of the cursor at the given index\n                 * @param ev {Event}\n                 * @param index {number}\n                 * @returns {number}\n                 */\n                function cursorPosition( ev, index ) {\n                    var position = -1 * scope.dimensions().sliderOffset;\n                    if ( ctrl.options.vertical ) {\n                        position += ev.touches ? ev.touches[ index ].pageY : ev.pageY;\n                    } else {\n                        position += ev.touches ? ev.touches[ index ].pageX : ev.pageX;\n                    }\n                    return position;\n                }\n\n                /**\n                 * Get the current position of the given knob\n                 * @param knob {angular.element}\n                 * @returns {number}\n                 */\n                function knobPosition( knob ) {\n                    var offset = ctrl.options.vertical ? knob[ 0 ].offsetTop : knob[ 0 ].offsetLeft;\n                    return offset - scope.dimensions().sliderOffset;\n                }\n\n                // add the bars\n                elem.prepend( $compile( '<drg-slider-bar low=\"' + $interpolate.startSymbol() + ' bar.low() ' + $interpolate.endSymbol() + '\" high=\"' + $interpolate.startSymbol() + ' bar.high() ' + $interpolate.endSymbol() + '\" ng-repeat=\"bar in bars\"></ng-slider-bar>' )( scope ) );\n\n                /**\n                 * Get the current slider size and offset\n                 * @returns {{sliderSize: number, sliderOffset: number}}\n                 */\n                scope.dimensions = function () {\n                    // get the offset for the slider\n                    var offset = ctrl.options.vertical ? elem[ 0 ].offsetTop : elem[ 0 ].offsetLeft;\n\n                    if ( elem[ 0 ].offsetParent ) {\n                        // take into account the offset of this element's parent\n                        offset += ctrl.options.vertical ? elem[ 0 ].offsetParent.offsetTop : elem[ 0 ].offsetParent.offsetLeft;\n                    }\n\n                    return {\n                        sliderSize : ctrl.options.vertical ? elem[ 0 ].offsetHeight : elem[ 0 ].offsetWidth,\t// get the size of the slider\n                        sliderOffset : offset\n                    };\n                };\n\n                /**\n                 * What to do when the user starts sliding\n                 * @param ev {Event}\n                 */\n                scope.onStart = function ( ev ) {\n                    // get the index of the touch/mouse\n                    var index = 0;\n                    if ( ev.targetTouches ) {\n                        index = ev.targetTouches[ 0 ].identifier;\n                    }\n\n                    // save the starting position(s)\n                    if ( angular.isArray( scope.currentKnobs[ index ] ) && scope.currentKnobs[ index ].length > 1 ) {\n                        var cursorPos = cursorPosition( ev, index );\n                        scope.startOffsets[ index ] = scope.currentKnobs[ index ].map( function ( knob ) {\n                            return knobPosition( knob.elem ) - cursorPos;\n                        } );\n                    } else {\n                        scope.startOffsets[ index ] = [ 0 ];\n                    }\n\n                    // fire a \"move\"\n                    scope.onMove( ev );\n                };\n\n                /**\n                 * What to do when a knob is moved\n                 * @param ev {Event}\n                 */\n                scope.onMove = function ( ev ) {\n                    // get the current dimensions\n                    var dimensions = scope.dimensions();\n\n                    angular.forEach( scope.currentKnobs, function ( knobs, index ) {\n                        if ( scope.currentKnobs[ index ] ) {\n                            // get the current mouse position\n                            var position = cursorPosition( ev, index );\n\n                            var startOffsets = scope.startOffsets[ index ];\n\n                            if ( !angular.isArray( knobs ) ) {\n                                knobs = [ knobs ];\n                            }\n\n                            // get the size of the knob(s) being dragged\n                            for ( var i = 0; i < knobs.length; i++ ) {\n                                // get the size of the knob\n                                var knobSize = ctrl.options.vertical ? knobs[ i ].elem[ 0 ].offsetHeight : knobs[ i ].elem[ 0 ].offsetWidth;\n\n                                var min = 0;\n                                var max = 1;\n\n                                if( !ctrl.options.continuous ) {\n                                    var index = scope.knobs.indexOf( knobs[ i ] );\n                                    if( index > 0 ) {\n                                        min = ctrl.toPercent( scope.knobs[ index - 1 ].ngModel.$modelValue );\n                                    }\n                                    if( index < scope.knobs.length - 1 ) {\n                                        max = ctrl.toPercent( scope.knobs[ index + 1 ].ngModel.$modelValue );\n                                    }\n                                }\n\n                                // get the current mouse/finger position as a percentage\n                                var percent = Math.max( min, Math.min( ( position + startOffsets[ i ] - ( knobSize / 2 ) ) / ( dimensions.sliderSize - knobSize ), max ) );\n\n                                // compute the value from the percentage\n                                var value = ctrl.percentToValue( percent ).toFixed( ctrl.options.precision );\n\n                                // update the model for the knob being dragged\n                                knobs[ i ].ngModel.$setViewValue( value );\n                                if ( !scope.$$phase ) {\n                                    scope.$apply();\n                                }\n                            }\n                        }\n                    } );\n                };\n\n                /**\n                 * What to do when the slide is finished\n                 */\n                scope.onEnd = function ( index ) {\n                    // remove the knob from the list of knobs currently being dragged\n                    var knobs = scope.currentKnobs[ index ] || [];\n                    if( index < scope.currentKnobs.length ) {\n                        delete scope.currentKnobs[ index ];\n                    }\n\n                    if ( !angular.isArray( knobs ) ) {\n                        knobs = [ knobs ];\n                    }\n\n                    angular.forEach( knobs, function ( knob ) {\n                        // fire the knob's onEnd callback\n                        knob.onEnd();\n                    } );\n\n                    if ( scope.currentKnobs.length == 0 ) {\n                        // we're no longer sliding\n                        scope.sliding = false;\n                    }\n                };\n\n                scope.onResize = function() {\n                    scope.fix();\n                };\n\n                // set the default events\n                var moveEvents = [ 'mousemove', 'touchmove' ];\n                var cancelEvents = [ 'mousecancel', 'touchcancel' ];\n                var endEvents = [ 'mouseup', 'touchend' ];\n\n                if ( window.PointerEvent ) {\n                    // the browser supports javascript Pointer Events (currently only IE11), use those\n                    moveEvents = [ 'pointermove' ];\n                    cancelEvents = [ 'pointercancel' ];\n                    endEvents = [ 'pointerup' ];\n                } else if ( window.navigator.msPointerEnabled ) {\n                    // the browser supports M$'s javascript Pointer Events (IE10), use those\n                    moveEvents = [ 'MSPointerMove' ];\n                    cancelEvents = [ 'MSPointerCancel' ];\n                    endEvents = [ 'MSPointerUp' ];\n                }\n\n                // bind the move events\n                angular.forEach( moveEvents, function ( event ) {\n                    $document.bind( event, function ( ev ) {\n                        if ( scope.sliding ) {\n                            // they see me slidin', they hatin'\n                            ev.preventDefault();\n                            ev.stopPropagation();\n                            scope.onMove( ev );\n                        }\n                    } );\n                } );\n\n                // bind the end and cancel events\n                angular.forEach( cancelEvents.concat( endEvents ), function ( event ) {\n                    $document.bind( event, function ( ev ) {\n                        if ( scope.sliding ) {\n                            // it's electric, boogie woogie, woogie\n\n                            // fire the end events for the drags that are ending\n                            if ( ev.changedTouches ) {\n                                for ( var i = 0; i < ev.changedTouches.length; i++ ) {\n                                    scope.onEnd( ev.changedTouches[ i ].identifier );\n                                }\n                            } else {\n                                scope.onEnd( 0 );\n                            }\n                        }\n                    } );\n                } );\n\n                // watch for disabilities\n                scope.$watch( function () {\n                    return scope.$eval( attr.ngDisabled );\n                }, function ( disabled ) {\n                    // do we have disabilities?\n                    scope.disabled = angular.isDefined( disabled ) && disabled;\n\n                    // tell the DOM\n                    if ( scope.disabled ) {\n                        elem.addClass( 'disabled' );\n                    } else {\n                        elem.removeClass( 'disabled' );\n                    }\n\n                    if ( scope.sliding ) {\n                        // I wanna wake up where you are, I won't say anything at all\n                        angular.forEach( scope.currentKnobs.keys(), function ( index ) {\n                            scope.onEnd( index );\n                        } );\n                    }\n                } );\n\n                // watch the attributes and update as necessary\n                attr.$observe( 'ceiling', function ( ceiling ) {\n                    if( !ctrl.useValues() ) {\n                        ceiling = angular.isDefined( ceiling ) ? parseFloat( ceiling ) : 0;\n                        scope.ceiling = isNaN( ceiling ) ? 0 : ceiling;\n                        scope.onResize();\n                    }\n                } );\n                attr.$observe( 'floor', function ( floor ) {\n                    if( !ctrl.useValues() ) {\n                        floor = angular.isDefined( floor ) ? parseFloat( floor ) : 0;\n                        scope.floor = isNaN( floor ) ? 0 : floor;\n                        scope.onResize();\n                    }\n                } );\n                scope.$watch( function () {\n                    return scope.$eval( attr.drgSliderOptions );\n                }, function ( opts ) {\n                    ctrl.options = angular.extend( {}, ctrl.defaultOptions, angular.isDefined( opts ) && angular.isObject( opts ) ? opts : {} );\n                    ctrl.options.values.sort();\n                    if( ctrl.useValues() ) {\n                        scope.floor = ctrl.options.values[ 0 ];\n                        scope.ceiling = ctrl.options.values[ ctrl.options.values.length - 1 ];\n                    }\n                    if ( ctrl.options.vertical ) {\n                        elem.addClass( 'drg-slider-vertical' ).removeClass( 'drg-slider-horizontal' );\n                    } else {\n                        elem.addClass( 'drg-slider-horizontal' ).removeClass( 'drg-slider-vertical' );\n                    }\n                }, true );\n\n                scope.$on( 'drgSlider.resize', scope.onResize );\n            }\n        }\n    } );\n","angular.module( 'drg.slider' )\n    .directive( 'drgSliderKnob', function ( $parse ) {\n        return {\n            restrict : 'EA',\n            require : [ '^drgSlider', '^ngModel' ],\n            scope : true,\n            compile : function ( elem, attr ) {\n                // make sure we have a model\n                if ( angular.isUndefined( attr.ngModel ) ) {\n                    throw \"ngSliderKnob Error: ngModel not specified\";\n                }\n\n                return function ( scope, elem, attr, ctrls ) {\n                    // get the controllers\n                    var ngSliderCtrl = ctrls[ 0 ];\n                    var ngModelCtrl = ctrls[ 1 ];\n\n                    // is the knob enabled?\n                    scope.enabled = true;\n\n                    /**\n                     * Make sure the value gets applied up the hierarchy\n                     * @param value {number}\n                     */\n                    function updateModel( value ) {\n                        $parse( attr.ngModel ).assign( scope.$parent.$parent, parseFloat( value ) );\n                        if ( !scope.$$phase ) {\n                            scope.$apply();\n                        }\n                    }\n\n                    // register the knob\n                    var knob = ngSliderCtrl.registerKnob( {\n                        ngModel : ngModelCtrl,\t\t\t// the model\n                        elem : elem,\t\t\t\t\t\t// the knob DOM element\n                        onChange : function ( value ) {\t\t// what to do when the model changes\n                            // sync the model\n                            updateModel( value );\n\n                            // expose the value to the scope\n                            scope.$viewValue = value;\n\n                            // set the CSS as needed\n                            elem.css( ngSliderCtrl.options.vertical ? 'top' : 'left', ngSliderCtrl.valueToPercent( value, elem ) + '%' );\n                        },\n                        onStart : function () {\t\t\t// what to do when the user starts dragging this knob\n                            elem.addClass( 'active' );\n                        },\n                        onEnd : function () {\t\t\t\t// what to do when the user stops dragging this knob\n                            elem.removeClass( 'active' );\n                        }\n                    } );\n\n                    // watch for disabilities\n                    scope.$watch( function () {\n                        return scope.$eval( attr.ngDisabled );\n                    }, function ( disabled ) {\n                        // is the knob disabled?\n                        scope.enabled = !disabled;\n\n                        // tell the DOM\n                        if ( disabled ) {\n                            elem.addClass( 'disabled' );\n                        } else {\n                            elem.removeClass( 'disabled' );\n                        }\n\n                        // tell the slider this knob is disabled\n                        scope.enabled || knob.disabled()\n                    } );\n\n                    // set the default events\n                    var events = [ 'mousedown', 'touchstart' ];\n                    if ( window.PointerEvent ) {\n                        // the browser supports javascript Pointer Events (currently only IE11), use those\n                        events = [ 'pointerdown' ];\n                    } else if ( window.navigator.MSPointerEnabled ) {\n                        // the browser supports M$'s javascript Pointer Events (IE10), use those\n                        events = [ 'MSPointerDown' ]\n                    }\n\n                    // bind the start events\n                    angular.forEach( events, function ( event ) {\n                        elem.bind( event, function ( ev ) {\n                            ev.preventDefault();\n                            ev.stopPropagation();\n                            knob.start( ev );\n                        } );\n                    } );\n                };\n            }\n        }\n    } );"],"sourceRoot":"/source/"}