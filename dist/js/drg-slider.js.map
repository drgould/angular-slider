{"version":3,"sources":["app.js","bar_directive.js","controller.js","directive.js","knob_directive.js"],"names":[],"mappings":"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","file":"drg-slider.js","sourcesContent":["angular.module('drg.slider', []);\n","angular.module( 'drg.slider' )\n    .directive( 'drgSliderBar', function () {\n        return {\n            restrict : 'EA',\n            require : '^drgSlider',\n            compile : function ( elem, attr ) {\n                return function ( scope, elem, attr, ngSliderCtrl ) {\n                    // set up the defaults\n                    scope.low = 0;\n                    scope.high = 0;\n                    scope.lowKnob = null;\n                    scope.highKnob = null;\n\n                    /**\n                     * keep the bar the correct size\n                     */\n                    function updateBar() {\n                        // get the bar's offset\n                        var offset = ngSliderCtrl.valueToPercent( scope.low, scope.lowKnob ? scope.lowKnob.elem : null, true );\n\n                        // compute the size of the bar\n                        var size = ngSliderCtrl.valueToPercent( scope.high, scope.highKnob ? scope.highKnob.elem : null, true ) - offset;\n\n                        // set the CSS\n                        if( ngSliderCtrl.options.vertical ) {\n                            elem.css( {\n                                top : offset + '%',\n                                height : size + '%'\n                            } );\n                        } else {\n                            elem.css( {\n                                left : offset + '%',\n                                width : size + '%'\n                            } );\n                        }\n                    }\n\n                    // register this bar with the slider\n                    var bar = ngSliderCtrl.registerBar( {\n                        elem : elem,\n                        scope : scope,\n                        onStart : function () {\n                            elem.addClass( 'active' );\n                        },\n                        onChange : function () {\n                            updateBar();\n                        },\n                        onEnd : function () {\n                            elem.removeClass( 'active' );\n                        }\n                    } );\n\n                    // watch the attributes for updates\n                    attr.$observe( 'low', function ( low ) {\n                        scope.low = low;\n                        updateBar();\n                    } );\n                    attr.$observe( 'high', function ( high ) {\n                        scope.high = high;\n                        updateBar();\n                    } );\n\n                    // set the default events\n                    var events = [ 'mousedown', 'touchstart' ];\n                    if ( window.PointerEvent ) {\n                        // the browser supports javascript Pointer Events (currently only IE11), use those\n                        events = [ 'pointerdown' ];\n                    } else if ( window.navigator.MSPointerEnabled ) {\n                        // the browser supports M$'s javascript Pointer Events (IE10), use those\n                        events = [ 'MSPointerDown' ]\n                    }\n\n                    // bind the start events\n                    angular.forEach( events, function ( event ) {\n                        elem.bind( event, function ( ev ) {\n                            ev.preventDefault();\n                            ev.stopPropagation();\n                            bar.start( ev );\n                        } );\n                    } );\n                }\n            }\n        }\n    } );","angular.module( 'drg.slider' )\n    .controller( 'SliderCtrl', function ( $scope, $timeout ) {\n\n        // keep track of the registered knobs\n        $scope.knobs = [];\n\n        // keep track of the bars that have been created\n        $scope.bars = [];\n\n        // store the bars registered\n        var registeredBars = [];\n\n        // we'll use this to tell which knob is currently being moved\n        $scope.currentKnobs = [];\n        $scope.startOffsets = [];\n        $scope.sliding = false;\n\n        // set the default options\n        this.defaultOptions = {\n            precision : 0,\n            buffer : 0,\n            steps : 0,\n            addStepNumbers : false,\n            stickiness : 3,\n            scale : function ( val ) {\n                return val;\n            },\n            continuous : false,\n            vertical : false\n        };\n        // reference the options locally to avoid any scoping issues\n        this.options = this.defaultOptions;\n\n        var ctrl = this;\n\n        function knobSort( a, b ) {\n            var a_val = a.ngModel.$modelValue;\n            var b_val = b.ngModel.$modelValue;\n            return a_val > b_val ? 1 : (b_val > a_val ? -1 : 0);\n        }\n\n        /**\n         * Sort the knobs by model value\n         */\n        function updateKnobs() {\n            $scope.knobs.sort( knobSort );\n            angular.forEach( $scope.knobs, function( knob ) {\n                knob.ngModel.$modelValue = Math.max( $scope.floor, Math.min( knob.ngModel.$modelValue, $scope.ceiling ) );\n            } );\n        }\n\n        /**\n         * Add a bar\n         */\n        function addBar() {\n            $scope.bars.push( {\n                low : function () {\n                    return 0;\n                },\n                high : function () {\n                    return 0;\n                }\n            } );\n        }\n\n        /**\n         * Remove a bar\n         */\n        function removeBar() {\n            $scope.bars.splice( 0, 1 );\n        }\n\n        /**\n         * Make sure the correct number of bars exist and all have the right data\n         */\n        function updateBars() {\n            // get the knob count\n            var numKnobs = $scope.knobs.length;\n\n            // add bars so we have one more bar than knobs\n            while ( $scope.bars.length < numKnobs + 1 ) {\n                addBar();\n            }\n\n            // remove bars so we have one more bar than knobs\n            while ( $scope.bars.length > numKnobs + 1 ) {\n                removeBar();\n            }\n\n            /**\n             * Isolate the index from the for loop below so the low value is always correct\n             * @param index {number}\n             * @returns {Function}\n             */\n            function lowFn( index ) {\n                /**\n                 * Get the low value for the bar\n                 * @returns {number}\n                 */\n                return function () {\n                    return index > 0 ? $scope.knobs[ index - 1 ].ngModel.$modelValue : $scope.floor;\n                }\n            }\n\n            /**\n             * Isolate the index from the for loop below so the high value is always correct\n             * @param index {number}\n             * @returns {Function}\n             */\n            function highFn( index ) {\n                /**\n                 * Get the high value for the bar\n                 * @returns {number}\n                 */\n                return function () {\n                    return index < $scope.knobs.length ? $scope.knobs[ index ].ngModel.$modelValue : $scope.ceiling;\n                }\n            }\n\n            // update the low and high values for the bars\n            angular.forEach( $scope.bars, function ( bar, b ) {\n                bar.low = lowFn( b );\n                bar.high = highFn( b );\n            } );\n\n            // update the knobs and fire the change callback for all registered bars\n            angular.forEach( registeredBars, function ( bar, index ) {\n                bar.scope.lowKnob = index > 0 ? $scope.knobs[ index - 1 ] : null;\n                bar.scope.highKnob = index < $scope.knobs.length ? $scope.knobs[ index ] : null;\n                bar.onChange && bar.onChange();\n            } );\n        }\n\n        /**\n         * Call this to refresh the slider\n         */\n        $scope.fix = function () {\n            updateKnobs();\n            updateBars();\n        };\n\n        /**\n         * Convert a value to the correct percentage for display purposes\n         * @param value {number}\n         * @param knob {angular.element}\n         * @param bar {boolean}\n         * @returns {number}\n         */\n        this.valueToPercent = function ( value, knob, bar ) {\n            // default the knob to a size of 0\n            var knobSize = 0;\n\n            if ( knob ) {\n                // we've been given a knob, get the size\n                knobSize = this.options.vertical ? knob[ 0 ].offsetHeight : knob[ 0 ].offsetWidth;\n            }\n\n            // compute the percentage size of the knob\n            var knobPercent = knobSize / $scope.dimensions().sliderSize * 100;\n\n            // compute the percent offset of the knob taking into account he size of the knob\n            var percent = ( ( ( parseFloat( value ) - $scope.floor ) / ( $scope.ceiling - $scope.floor ) ) * ( 100 - knobPercent ) );\n\n            if ( bar && knob ) {\n                // we're computing this for a bar and we've been given a knob, add half of the knob back to keep the bar in the middle of the knob\n                percent += knobPercent / 2;\n            }\n\n            return percent;\n        };\n\n        /**\n         * Add the knob to the slider and return some useful functions\n         * @param knob {object}\n         * @returns {{start: start, disabled: disabled}}\n         */\n        this.registerKnob = function ( knob ) {\n\n            // is this knob enabled?\n            var enabled = true;\n\n            // add the knob to the list\n            $scope.knobs.push( knob );\n\n            /**\n             * Normalize the value so it adheres to these criteria:\n             *    - within bounds of the slider\n             *    - if not continuous, previous and next knobs are <= or >=, respectively\n             *    - if > 1 step, falls on a step\n             *    - has the given decimal precision\n             * Then fire this knob's onChange callback if the normalized value is the same as the given value\n             * @param value {number}\n             */\n            function normalizeModel( value ) {\n\n                // initialize the bounds\n                var ceiling = $scope.ceiling;\n                var floor = $scope.floor;\n\n                // start with the original value\n                var normalized = parseFloat( value );\n\n                // get the index of the knob so we know the surrounding knobs\n                var index = $scope.knobs.indexOf( knob );\n\n                if ( !ctrl.options.continuous ) {\n                    // keep the knobs contained to their section of the slider\n\n                    if ( index > 0 ) {\n                        // this isn't the knob with the lowest value, set the floor to the value of the knob lower than this\n                        floor = parseFloat( $scope.knobs[ index - 1 ].ngModel.$modelValue ) + (ctrl.options.buffer > 0 ? ctrl.options.buffer : 0);\n                    }\n                    if ( index < $scope.knobs.length - 1 ) {\n                        // this isn't the knob with the highest value, set the ceiling to the value of the knob higher than this\n                        ceiling = parseFloat( $scope.knobs[ index + 1 ].ngModel.$modelValue ) - (ctrl.options.buffer > 0 ? ctrl.options.buffer : 0);\n                    }\n                }\n\n                if ( ctrl.options.steps > 1 ) {\n                    // there should be more than one step\n\n                    // get the width of a step\n                    var stepWidth = ($scope.ceiling - $scope.floor) / (ctrl.options.steps - 1);\n\n                    if ( index > 0 ) {\n                        // this isn't the knob with the lowest value, make sure the floor aligns with a step\n                        var floorMod = (floor - $scope.floor) % stepWidth;\n                        if ( floorMod > 0 ) {\n                            floor += stepWidth - floorMod;\n                        }\n                    }\n\n                    if ( index < $scope.knobs.length - 1 ) {\n                        // this isn't the knob with the highest value, make sure the ceiling aligns with a step\n                        var ceilingMod = (ceiling - $scope.floor) % stepWidth;\n                        if ( ceilingMod > 0 ) {\n                            ceiling -= ceilingMod;\n                        }\n                    }\n\n                    // align the value with a step\n                    var mod = (normalized - $scope.floor) % stepWidth;\n                    if ( mod < stepWidth / 2 ) {\n                        normalized -= mod;\n                    } else {\n                        normalized += stepWidth - mod;\n                    }\n                }\n\n                // ensure the value is within the bounds\n                normalized = Math.min( ceiling, Math.max( normalized, floor ) );\n\n                if ( ctrl.options.precision >= 0 ) {\n                    // format the value to the correct decimal precision\n                    normalized = parseFloat( normalized.toFixed( ctrl.options.precision ) );\n                }\n\n                if ( normalized === value ) {\n                    // the normalized value is the same as the original, fire the onChange callback for this knob\n                    knob.onChange && knob.onChange( value );\n                } else if ( !isNaN( normalized ) ) {\n                    // the normalized value is different than the original (an it's a number), update the model\n                    knob.ngModel.$setViewValue( normalized );\n                    if ( !$scope.$$phase ) {\n                        $scope.$apply();\n                    }\n                }\n            }\n\n            /**\n             * Do what's needed to update the DOM\n             * @param value\n             */\n            function update( value ) {\n                if ( enabled ) {\n                    // normalize\n                    normalizeModel( value );\n\n                    // fix the DOM\n                    $scope.fix();\n\n                    // make sure the changes are digested\n                    if ( !$scope.$$phase ) {\n                        $scope.$apply();\n                    }\n                }\n            }\n\n            // watch this knob's model for changes\n            $scope.$watch( function () {\n                return knob.ngModel.$modelValue;\n            }, function ( value ) {\n                update( value );\n            } );\n\n            // watch for updates on the slider and update accordingly\n            //$scope.$watch( 'floor', function () {\n            //    update( knob.ngModel.$modelValue );\n            //} );\n            //$scope.$watch( 'ceiling', function () {\n            //    update( knob.ngModel.$modelValue );\n            //} );\n            $scope.$watch( function () {\n                return ctrl.options;\n            }, function () {\n                update( knob.ngModel.$modelValue );\n            }, true );\n\n            // initialize the bars\n            updateBars();\n\n            // listen for when this knob is removed from the DOM, remove it from the list and set to disabled\n            knob.elem.on( '$destroy', function () {\n                $scope.knobs.splice( $scope.knobs.indexOf( knob ), 1 );\n                enabled = false;\n            } );\n\n            // give the knob some useful functions\n            return {\n                start : function ( ev ) {\n                    if ( !$scope.disabled ) {\n                        if ( angular.isDefined( ev.targetTouches ) ) {\n                            $scope.currentKnobs[ ev.targetTouches[ 0 ].identifier ] = [ knob ];\n                        } else {\n                            $scope.currentKnobs[ 0 ] = [ knob ];\n                        }\n                        $scope.sliding = true;\n                        $scope.onStart( ev );\n                        knob.onStart();\n                    }\n                },\n                disabled : function () {\n                    var index = $scope.currentKnobs.indexOf( knob );\n                    if ( $scope.sliding && index >= 0 ) {\n                        $scope.onEnd( index );\n                    }\n                }\n            }\n        };\n\n        /**\n         * Add the bar to the slider\n         * @param bar {object}\n         * @return {{start: start}}\n         */\n        this.registerBar = function ( bar ) {\n            // add the bar to the list\n            registeredBars.push( bar );\n\n            // listen for when this bar is removed from the DOM and remove it from the list\n            bar.elem.on( '$destroy', function () {\n                var index = registeredBars.indexOf( bar );\n                if ( index >= 0 ) {\n                    registeredBars.splice( index, 1 );\n                }\n            } );\n\n            return {\n                start : function ( ev ) {\n                    if ( !$scope.disabled ) {\n                        var knobs = [];\n                        if ( bar.scope.lowKnob ) {\n                            knobs.push( bar.scope.lowKnob );\n                        }\n                        if ( bar.scope.highKnob ) {\n                            knobs.push( bar.scope.highKnob );\n                        }\n                        if ( angular.isDefined( ev.targetTouches ) ) {\n                            $scope.currentKnobs[ ev.targetTouches[ 0 ].identifier ] = knobs;\n                        } else {\n                            $scope.currentKnobs[ 0 ] = knobs;\n                        }\n                        $scope.sliding = true;\n                        $scope.onStart( ev );\n                        bar.onStart();\n                    }\n                }\n            }\n        }\n    } );\n","angular.module( 'drg.slider' )\n    .directive( 'drgSlider', function ( $document, $compile, $interpolate ) {\n        return {\n            restrict : 'EA',\n            controller : 'SliderCtrl',\n            scope : true,\n            compile : function ( elem, attr ) {\n                // check requirements\n                if ( angular.isUndefined( attr.floor ) ) {\n                    throw \"ngSlider Error: Floor not specified\";\n                }\n                if ( angular.isUndefined( attr.ceiling ) ) {\n                    throw \"ngSlider Error: Ceiling not specified\";\n                }\n\n                return function ( scope, elem, attr, ctrl ) {\n\n                    /**\n                     * Get the current relative position of the cursor at the given index\n                     * @param ev {Event}\n                     * @param index {number}\n                     * @returns {number}\n                     */\n                    function cursorPosition( ev, index ) {\n                        var position = -1 * scope.dimensions().sliderOffset;\n                        if ( ctrl.options.vertical ) {\n                            position += ev.touches ? ev.touches[ index ].pageY : ev.pageY;\n                        } else {\n                            position += ev.touches ? ev.touches[ index ].pageX : ev.pageX;\n                        }\n                        return position;\n                    }\n\n                    /**\n                     * Get the current position of the given knob\n                     * @param knob {angular.element}\n                     * @returns {number}\n                     */\n                    function knobPosition( knob ) {\n                        var offset = ctrl.options.vertical ? knob[ 0 ].offsetTop : knob[ 0 ].offsetLeft;\n                        return offset - scope.dimensions().sliderOffset;\n                    }\n\n                    // add the bars\n                    elem.prepend( $compile( '<drg-slider-bar low=\"' + $interpolate.startSymbol() + ' bar.low() ' + $interpolate.endSymbol() + '\" high=\"' + $interpolate.startSymbol() + ' bar.high() ' + $interpolate.endSymbol() + '\" ng-repeat=\"bar in bars\"></ng-slider-bar>' )( scope ) );\n\n                    /**\n                     * Get the current slider size and offset\n                     * @returns {{sliderSize: number, sliderOffset: number}}\n                     */\n                    scope.dimensions = function () {\n                        // get the offset for the slider\n                        var offset = ctrl.options.vertical ? elem[ 0 ].offsetTop : elem[ 0 ].offsetLeft;\n\n                        if ( elem[ 0 ].offsetParent ) {\n                            // take into account the offset of this element's parent\n                            offset += ctrl.options.vertical ? elem[ 0 ].offsetParent.offsetTop : elem[ 0 ].offsetParent.offsetLeft;\n                        }\n\n                        return {\n                            sliderSize : ctrl.options.vertical ? elem[ 0 ].offsetHeight : elem[ 0 ].offsetWidth,\t// get the size of the slider\n                            sliderOffset : offset\n                        };\n                    };\n\n                    /**\n                     * What to do when the user starts sliding\n                     * @param ev {Event}\n                     */\n                    scope.onStart = function ( ev ) {\n                        // get the index of the touch/mouse\n                        var index = 0;\n                        if ( ev.targetTouches ) {\n                            index = ev.targetTouches[ 0 ].identifier;\n                        }\n\n                        // save the starting position(s)\n                        if ( angular.isArray( scope.currentKnobs[ index ] ) && scope.currentKnobs[ index ].length > 1 ) {\n                            var cursorPos = cursorPosition( ev, index );\n                            scope.startOffsets[ index ] = scope.currentKnobs[ index ].map( function ( knob ) {\n                                return knobPosition( knob.elem ) - cursorPos;\n                            } );\n                        } else {\n                            scope.startOffsets[ index ] = [ 0 ];\n                        }\n\n                        // fire a \"move\"\n                        scope.onMove( ev );\n                    };\n\n                    /**\n                     * What to do when a knob is moved\n                     * @param ev {Event}\n                     */\n                    scope.onMove = function ( ev ) {\n                        // get the current dimensions\n                        var dimensions = scope.dimensions();\n\n                        angular.forEach( scope.currentKnobs, function ( knobs, index ) {\n                            if ( scope.currentKnobs[ index ] ) {\n                                // get the current mouse position\n                                var position = cursorPosition( ev, index );\n\n                                var startOffsets = scope.startOffsets[ index ];\n\n                                if ( !angular.isArray( knobs ) ) {\n                                    knobs = [ knobs ];\n                                }\n\n                                // get the size of the knob(s) being dragged\n                                for ( var i = 0; i < knobs.length; i++ ) {\n                                    // get the size of the knob\n                                    var knobSize = ctrl.options.vertical ? knobs[ i ].elem[ 0 ].offsetHeight : knobs[ i ].elem[ 0 ].offsetWidth;\n\n                                    // get the current mouse/finger position as a percentage\n                                    var percent = Math.max( 0, Math.min( (position + startOffsets[ i ] - (knobSize / 2)) / (dimensions.sliderSize - knobSize), 1 ) );\n\n                                    // compute the value from the percentage\n                                    var value = ((percent * (scope.ceiling - scope.floor)) + scope.floor).toFixed( ctrl.options.precision );\n\n                                    // update the model for the knob being dragged\n                                    knobs[ i ].ngModel.$setViewValue( value );\n                                    if ( !scope.$$phase ) {\n                                        scope.$apply();\n                                    }\n                                }\n                            }\n                        } );\n                    };\n\n                    /**\n                     * What to do when the slide is finished\n                     */\n                    scope.onEnd = function ( index ) {\n                        // remove the knob from the list of knobs currently being dragged\n                        var knobs = scope.currentKnobs[ index ] || [];\n                        if( index < scope.currentKnobs.length ) {\n                            delete scope.currentKnobs[ index ];\n                        }\n\n                        if ( !angular.isArray( knobs ) ) {\n                            knobs = [ knobs ];\n                        }\n\n                        angular.forEach( knobs, function ( knob ) {\n                            // fire the knob's onEnd callback\n                            knob.onEnd();\n                        } );\n\n                        if ( scope.currentKnobs.length == 0 ) {\n                            // we're no longer sliding\n                            scope.sliding = false;\n                        }\n                    };\n\n                    scope.onResize = function() {\n                        scope.fix();\n                    };\n\n                    // set the default events\n                    var moveEvents = [ 'mousemove', 'touchmove' ];\n                    var cancelEvents = [ 'mousecancel', 'touchcancel' ];\n                    var endEvents = [ 'mouseup', 'touchend' ];\n\n                    if ( window.PointerEvent ) {\n                        // the browser supports javascript Pointer Events (currently only IE11), use those\n                        moveEvents = [ 'pointermove' ];\n                        cancelEvents = [ 'pointercancel' ];\n                        endEvents = [ 'pointerup' ];\n                    } else if ( window.navigator.msPointerEnabled ) {\n                        // the browser supports M$'s javascript Pointer Events (IE10), use those\n                        moveEvents = [ 'MSPointerMove' ];\n                        cancelEvents = [ 'MSPointerCancel' ];\n                        endEvents = [ 'MSPointerUp' ];\n                    }\n\n                    // bind the move events\n                    angular.forEach( moveEvents, function ( event ) {\n                        $document.bind( event, function ( ev ) {\n                            if ( scope.sliding ) {\n                                // they see me slidin', they hatin'\n                                ev.preventDefault();\n                                ev.stopPropagation();\n                                scope.onMove( ev );\n                            }\n                        } );\n                    } );\n\n                    // bind the end and cancel events\n                    angular.forEach( cancelEvents.concat( endEvents ), function ( event ) {\n                        $document.bind( event, function ( ev ) {\n                            if ( scope.sliding ) {\n                                // it's electric, boogie woogie, woogie\n\n                                // fire the end events for the drags that are ending\n                                if ( ev.changedTouches ) {\n                                    for ( var i = 0; i < ev.changedTouches.length; i++ ) {\n                                        scope.onEnd( ev.changedTouches[ i ].identifier );\n                                    }\n                                } else {\n                                    scope.onEnd( 0 );\n                                }\n                            }\n                        } );\n                    } );\n\n                    // watch for disabilities\n                    scope.$watch( function () {\n                        return scope.$eval( attr.ngDisabled );\n                    }, function ( disabled ) {\n                        // do we have disabilities?\n                        scope.disabled = angular.isDefined( disabled ) && disabled;\n\n                        // tell the DOM\n                        if ( scope.disabled ) {\n                            elem.addClass( 'disabled' );\n                        } else {\n                            elem.removeClass( 'disabled' );\n                        }\n\n                        if ( scope.sliding ) {\n                            // I wanna wake up where you are, I won't say anything at all\n                            angular.forEach( scope.currentKnobs.keys(), function ( index ) {\n                                scope.onEnd( index );\n                            } );\n                        }\n                    } );\n\n                    // watch the attributes and update as necessary\n                    attr.$observe( 'ceiling', function ( ceiling ) {\n                        ceiling = angular.isDefined( ceiling ) ? parseFloat( ceiling ) : 0;\n                        scope.ceiling = isNaN( ceiling ) ? 0 : ceiling;\n                        scope.onResize();\n                    } );\n                    attr.$observe( 'floor', function ( floor ) {\n                        floor = angular.isDefined( floor ) ? parseFloat( floor ) : 0;\n                        scope.floor = isNaN( floor ) ? 0 : floor;\n                        scope.onResize();\n                    } );\n                    scope.$watch( function () {\n                        return scope.$eval( attr.drgSliderOptions );\n                    }, function ( opts ) {\n                        ctrl.options = angular.extend( {}, ctrl.defaultOptions, angular.isDefined( opts ) && angular.isObject( opts ) ? opts : {} );\n                        if ( ctrl.options.vertical ) {\n                            elem.addClass( 'drg-slider-vertical' ).removeClass( 'drg-slider-horizontal' );\n                        } else {\n                            elem.addClass( 'drg-slider-horizontal' ).removeClass( 'drg-slider-vertical' );\n                        }\n                    }, true );\n\n                    scope.$on( 'drgSlider.resize', scope.onResize );\n                };\n            }\n        }\n    } );\n","angular.module( 'drg.slider' )\n    .directive( 'drgSliderKnob', function ( $parse ) {\n        return {\n            restrict : 'EA',\n            require : [ '^drgSlider', '^ngModel' ],\n            scope : true,\n            compile : function ( elem, attr ) {\n                // make sure we have a model\n                if ( angular.isUndefined( attr.ngModel ) ) {\n                    throw \"ngSliderKnob Error: ngModel not specified\";\n                }\n\n                return function ( scope, elem, attr, ctrls ) {\n                    // get the controllers\n                    var ngSliderCtrl = ctrls[ 0 ];\n                    var ngModelCtrl = ctrls[ 1 ];\n\n                    // is the knob enabled?\n                    scope.enabled = true;\n\n                    /**\n                     * Make sure the value gets applied up the hierarchy\n                     * @param value {number}\n                     */\n                    function updateModel( value ) {\n                        $parse( attr.ngModel ).assign( scope.$parent.$parent, parseFloat( value ) );\n                        if ( !scope.$$phase ) {\n                            scope.$apply();\n                        }\n                    }\n\n                    // register the knob\n                    var knob = ngSliderCtrl.registerKnob( {\n                        ngModel : ngModelCtrl,\t\t\t// the model\n                        elem : elem,\t\t\t\t\t\t// the knob DOM element\n                        onChange : function ( value ) {\t\t// what to do when the model changes\n                            // sync the model\n                            updateModel( value );\n\n                            // expose the value to the scope\n                            scope.$viewValue = value;\n\n                            // set the CSS as needed\n                            elem.css( ngSliderCtrl.options.vertical ? 'top' : 'left', ngSliderCtrl.valueToPercent( value, elem ) + '%' );\n                        },\n                        onStart : function () {\t\t\t// what to do when the user starts dragging this knob\n                            elem.addClass( 'active' );\n                        },\n                        onEnd : function () {\t\t\t\t// what to do when the user stops dragging this knob\n                            elem.removeClass( 'active' );\n                        }\n                    } );\n\n                    // watch for disabilities\n                    scope.$watch( function () {\n                        return scope.$eval( attr.ngDisabled );\n                    }, function ( disabled ) {\n                        // is the knob disabled?\n                        scope.enabled = !disabled;\n\n                        // tell the DOM\n                        if ( disabled ) {\n                            elem.addClass( 'disabled' );\n                        } else {\n                            elem.removeClass( 'disabled' );\n                        }\n\n                        // tell the slider this knob is disabled\n                        scope.enabled || knob.disabled()\n                    } );\n\n                    // set the default events\n                    var events = [ 'mousedown', 'touchstart' ];\n                    if ( window.PointerEvent ) {\n                        // the browser supports javascript Pointer Events (currently only IE11), use those\n                        events = [ 'pointerdown' ];\n                    } else if ( window.navigator.MSPointerEnabled ) {\n                        // the browser supports M$'s javascript Pointer Events (IE10), use those\n                        events = [ 'MSPointerDown' ]\n                    }\n\n                    // bind the start events\n                    angular.forEach( events, function ( event ) {\n                        elem.bind( event, function ( ev ) {\n                            ev.preventDefault();\n                            ev.stopPropagation();\n                            knob.start( ev );\n                        } );\n                    } );\n                };\n            }\n        }\n    } );"],"sourceRoot":"/source/"}