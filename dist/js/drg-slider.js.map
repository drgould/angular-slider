{"version":3,"sources":["app.js","bar_directive.js","controller.js","directive.js","knob_directive.js"],"names":[],"mappings":"AAAA;;;;;;AAMA;;AAAA,QAAQ,OAAO,cAAc,IAAI;ACNjC;;AAAA,QAAQ,OAAQ,cACX,UAAW,gBAAgB,YAAY;IACpC,OAAO;QACH,UAAW;QACX,SAAU;QACV,SAAU,SAAA,QAAW,MAAM,MAAO;YAC9B,OAAO,UAAW,OAAO,MAAM,MAAM,cAAe;;gBAEhD,MAAM,MAAM;gBACZ,MAAM,OAAO;gBACb,MAAM,UAAU;gBAChB,MAAM,WAAW;;;;;gBAKjB,SAAS,YAAY;;oBAEjB,IAAI,SAAS,aAAa,eAAgB,MAAM,KAAK,MAAM,UAAU,MAAM,QAAQ,OAAO,MAAM;;;oBAGhG,IAAI,OAAO,aAAa,eAAgB,MAAM,MAAM,MAAM,WAAW,MAAM,SAAS,OAAO,MAAM,QAAS;;;oBAG1G,IAAI,aAAa,QAAQ,UAAW;wBAChC,KAAK,IAAK;4BACN,KAAM,SAAS;4BACf,QAAS,OAAO;;2BAEjB;wBACH,KAAK,IAAK;4BACN,MAAO,SAAS;4BAChB,OAAQ,OAAO;;;;;;gBAM3B,IAAI,MAAM,aAAa,YAAa;oBAChC,MAAO;oBACP,OAAQ;oBACR,SAAU,SAAA,UAAY;wBAClB,KAAK,SAAU;;oBAEnB,UAAW,SAAA,WAAY;wBACnB;;oBAEJ,OAAQ,SAAA,QAAY;wBAChB,KAAK,YAAa;;;;;gBAK1B,KAAK,SAAU,OAAO,UAAW,KAAM;oBACnC,MAAM,MAAM;oBACZ;;gBAEJ,KAAK,SAAU,QAAQ,UAAW,MAAO;oBACrC,MAAM,OAAO;oBACb;;;;gBAIJ,IAAI,SAAS,CAAE,aAAa;gBAC5B,IAAK,OAAO,cAAe;;oBAEvB,SAAS,CAAE;uBACR,IAAK,OAAO,UAAU,kBAAmB;;oBAE5C,SAAS,CAAE;;;;gBAIf,QAAQ,QAAS,QAAQ,UAAW,OAAQ;oBACxC,KAAK,KAAM,OAAO,UAAW,IAAK;wBAC9B,GAAG;wBACH,GAAG;wBACH,IAAI,MAAO;;;;;;GAM/B;ACnFR;;AAAA,QAAQ,OAAQ,cACX,WAAY,qCAAc,UAAW,QAAQ,UAAW;IAEzD,IAAI,QAAQ;;IAAR,IAAI,gBAAgB;IACpB,IAAI,mBAAmB;;;IAGvB,OAAO,QAAQ;;;IAGf,OAAO,OAAO;;;IAGd,IAAI,iBAAiB;;;IAGrB,OAAO,eAAe;IACtB,OAAO,eAAe;IACtB,OAAO,UAAU;;;IAGjB,KAAK,iBAAiB;QAClB,WAAY;QACZ,QAAS;QACT,OAAQ;QACR,QAAS;QACT,SAAU;QACV,YAAa;QACb,UAAW;;;IAGf,KAAK,UAAU,KAAK;;IAEpB,IAAI,OAAO;;IAEX,SAAS,SAAU,GAAG,GAAI;QACtB,IAAI,QAAQ,EAAE,QAAQ;QACtB,IAAI,QAAQ,EAAE,QAAQ;QACtB,OAAO,QAAQ,QAAQ,IAAK,QAAQ,QAAQ,CAAC,IAAI;;;IAGrD,SAAS,YAAY;QACjB,OAAO,MAAM,KAAM;;;;;;IAMvB,SAAS,cAAc;QACnB;QACA,QAAQ,QAAS,OAAO,OAAO,UAAW,MAAO;YAC7C,KAAK,QAAQ,cAAc,KAAK,IAAK,OAAO,OAAO,KAAK,IAAK,KAAK,QAAQ,aAAa,OAAO;;;;;;;IAOtG,SAAS,SAAS;QACd,OAAO,KAAK,KAAM;YACd,KAAM,SAAA,MAAY;gBACd,OAAO;;YAEX,MAAO,SAAA,OAAY;gBACf,OAAO;;;;;;;;IAQnB,SAAS,YAAY;QACjB,OAAO,KAAK,OAAQ,GAAG;;;;;;IAM3B,SAAS,aAAa;;QAElB,IAAI,WAAW,OAAO,MAAM;;;QAG5B,OAAQ,OAAO,KAAK,SAAS,WAAW,GAAI;YACxC;;;;QAIJ,OAAQ,OAAO,KAAK,SAAS,WAAW,GAAI;YACxC;;;;;;;;QAQJ,SAAS,MAAO,OAAQ;;;;;YAKpB,OAAO,YAAY;gBACf,OAAO,QAAQ,IAAI,OAAO,MAAO,QAAQ,GAAI,QAAQ,cAAc,OAAO;;;;;;;;;QASlF,SAAS,OAAQ,OAAQ;;;;;YAKrB,OAAO,YAAY;gBACf,OAAO,QAAQ,OAAO,MAAM,SAAS,OAAO,MAAO,OAAQ,QAAQ,cAAc,OAAO;;;;;QAKhG,QAAQ,QAAS,OAAO,MAAM,UAAW,KAAK,GAAI;YAC9C,IAAI,MAAM,MAAO;YACjB,IAAI,OAAO,OAAQ;;;;QAIvB,QAAQ,QAAS,gBAAgB,UAAW,KAAK,OAAQ;YACrD,IAAI,MAAM,UAAU,QAAQ,IAAI,OAAO,MAAO,QAAQ,KAAM;YAC5D,IAAI,MAAM,WAAW,QAAQ,OAAO,MAAM,SAAS,OAAO,MAAO,SAAU;YAC3E,IAAI,YAAY,IAAI;;;;IAI5B,IAAI;;;;;IAKJ,OAAO,MAAM,YAAY;QACrB,SAAS,OAAQ;QACjB,cAAc,SAAU,YAAW;YAC/B;YACA;WACD;;;;;;;;;;;;IAYP,SAAS,aAAc,UAAkG;QAGzH,IAHiC,QAAK,UAAA,UAAA,KAAA,UAAA,OAAA,YAAC,OAAO,QAAK,UAAA;QAInD,IAJqD,UAAO,UAAA,UAAA,KAAA,UAAA,OAAA,YAAC,OAAO,UAAO,UAAA;QAK3E,IAL6E,UAAO,UAAA,UAAA,KAAA,UAAA,OAAA,YAAC,QAAK,UAAA;QAM1F,IAN4F,SAAM,UAAA,UAAA,KAAA,UAAA,OAAA,YAAC,KAAK,QAAQ,SAAM,UAAA;;QAClH,IAAI,KAAK,oBAAoB,CAAC,SAAU;;YAEpC,IAAI,UAAU,CAAE,WAAW,OAAO,UAAY,OAAO,UAAU,OAAO;YACtE,IAAI,QAAQ,KAAK,MAAO,WAAY,OAAO,SAAS;;YAEpD,OAAO,SAAS,KAAK,QAAQ,OAAO,QAAS;gBACzC,IAAI,OAAQ,SAAU,OAAQ;oBAC1B,IAAI,OAAQ,QAAQ,KAAM,SAAU;wBAChC,QAAQ,KAAM,oBAAoB,UAAU,OAAQ,QAAS,OAAQ,QAAQ,IAAK;wBAClF,OAAO;;oBAEX;uBACG,IAAI,OAAQ,SAAU,SAAU;oBACnC,IAAI,OAAQ,QAAQ,KAAM,OAAQ;wBAC9B,QAAQ,KAAM,8BAA8B,UAAU,OAAQ,QAAQ,IAAK,OAAQ,QAAS;wBAC5F,OAAO;;oBAEX;uBACG;oBACH,OAAO,OAAQ;;;;YAIvB,QAAQ,KAAM,4BAA4B,UAAU,OAAO,MAAM,IAAK,UAAA,MAAI;gBAQ1E,OAR8E,KAAK,QAAQ;gBAAe,QAAQ,OAAO;YACzH,OAAO;;;;QAIX,KAAK,IAAI,IAAI,GAAG,IAAI,OAAO,SAAS,GAAG,KAAM;;YAEzC,IAAI,YAAY,OAAQ,MAAO,YAAY,OAAQ,IAAI,IAAO;gBAC1D,IAAI,OAAQ,KAAM,SAAS,OAAQ,IAAI,KAAM,SAAU;oBACnD,QAAQ,KAAM,eAAe,UAAU,OAAQ,IAAK,OAAQ,IAAI,IAAK,OAAO;oBAC5E,OAAO;uBACJ,IAAI,OAAQ,KAAM,OAAQ;oBAC7B,OAAO,OAAQ,IAAI;uBAChB,IAAI,OAAQ,IAAI,KAAM,SAAU;oBACnC,OAAO,OAAQ;;;;gBAInB,OAAO,OAAQ,IAAI,KAAK,MAAO,CAAE,WAAW,OAAQ,OAAU,OAAQ,IAAI,KAAM,OAAQ;;;;QAIhG,IAAI,OAAQ,OAAO,SAAS,KAAM,SAAU;YACxC,QAAQ,KAAM,YAAY,UAAU,OAAQ,OAAO,SAAS,IAAK;YACjE,OAAO;;;QAGX,OAAO,OAAQ,OAAO,SAAS;;;;;;;;;;IAUnC,KAAK,iBAAiB,UAAW,OAAO,MAAM,KAAM;;QAEhD,IAAI,WAAW;;QAEf,IAAK,MAAO;;YAER,WAAW,KAAK,QAAQ,WAAW,KAAM,GAAI,eAAe,KAAM,GAAI;;;;QAI1E,IAAI,cAAc,WAAW,OAAO,aAAa,aAAa;;QAE9D,IAAI,UAAU;;QAEd,QAAQ,WAAY;;QAEpB,IAAI,KAAK,aAAc;YACnB,IAAI,SAAS,KAAK,QAAQ;;YAE1B,KAAM,IAAI,IAAI,GAAG,IAAI,OAAO,SAAS,GAAG,KAAM;;gBAE1C,IAAK,SAAS,OAAQ,MAAO,SAAS,OAAQ,IAAI,IAAM;;oBAEpD,IAAI,QAAQ,IAAI,KAAK,MAAO,CAAE,QAAQ,OAAQ,OAAU,OAAQ,IAAI,KAAM,OAAQ;oBAClF,IAAI,KAAK,kBAAmB;wBACxB,UAAU,SAAU,OAAO,SAAS;2BACjC;wBACH,UAAU,CAAE,OAAQ,SAAU,OAAO,UAAY,OAAO,UAAU,OAAO;;;;eAIlF;YACH,UAAU,CAAE,QAAQ,OAAO,UAAY,OAAO,UAAU,OAAO;;;;QAInE,UAAU,WAAY,MAAM;;QAE5B,IAAK,OAAO,MAAO;;YAEf,WAAW,cAAc;;;QAG7B,OAAO;;;;;;;;;;IAUX,KAAK,iBAAiB,UAAW,SAAsD;QAUvF,IAV0C,QAAK,UAAA,UAAA,KAAA,UAAA,OAAA,YAAC,OAAO,QAAK,UAAA;QAW5D,IAX8D,UAAO,UAAA,UAAA,KAAA,UAAA,OAAA,YAAC,OAAO,UAAO,UAAA;;;QAEhF,IAAI,QAAU,WAAY,UAAU,SAAY;;QAEhD,IAAI,KAAK,aAAc;;YAEnB,OAAO,aAAc,OAAO,OAAO;;;;QAIvC,OAAO;;;;;;;;IAQX,KAAK,YAAY,UAAU,OAAQ;QAC/B,OAAO,CAAE,QAAQ,OAAO,UAAY,OAAO,UAAU,OAAO;;;;;;;;IAQhE,KAAK,eAAe,UAAW,MAAO;;;QAGlC,IAAI,UAAU;;;QAGd,OAAO,MAAM,KAAM;QACnB;;;;;;;;;;;QAWA,SAAS,eAAgB,OAAQ;YAC7B;;;YAGA,IAAI,UAAU,OAAO;YACrB,IAAI,QAAQ,OAAO;;;YAGnB,IAAI,aAAa,WAAY;;;YAG7B,IAAI,QAAQ,OAAO,MAAM,QAAS;;YAElC,IAAK,CAAC,KAAK,QAAQ,YAAa;;;gBAG5B,IAAK,QAAQ,GAAI;;oBAEb,QAAQ,WAAY,OAAO,MAAO,QAAQ,GAAI,QAAQ,gBAAiB,KAAK,QAAQ,SAAS,IAAI,KAAK,QAAQ,SAAS;;gBAE3H,IAAK,QAAQ,OAAO,MAAM,SAAS,GAAI;;oBAEnC,UAAU,WAAY,OAAO,MAAO,QAAQ,GAAI,QAAQ,gBAAiB,KAAK,QAAQ,SAAS,IAAI,KAAK,QAAQ,SAAS;;;;YAIjI,IAAI,KAAK,aAAc;;gBAEnB,aAAa,aAAc,OAAO,OAAO,SAAS;mBAC/C,IAAK,KAAK,QAAQ,QAAQ,GAAI;;;;gBAIjC,IAAI,YAAY,CAAC,OAAO,UAAU,OAAO,UAAU,KAAK,QAAQ,QAAQ;;gBAExE,IAAK,QAAQ,GAAI;;oBAEb,IAAI,WAAW,CAAC,QAAQ,OAAO,SAAS;oBACxC,IAAK,WAAW,GAAI;wBAChB,SAAS,YAAY;;;;gBAI7B,IAAK,QAAQ,OAAO,MAAM,SAAS,GAAI;;oBAEnC,IAAI,aAAa,CAAC,UAAU,OAAO,SAAS;oBAC5C,IAAK,aAAa,GAAI;wBAClB,WAAW;;;;;gBAKnB,IAAI,MAAM,CAAC,aAAa,OAAO,SAAS;gBACxC,IAAK,MAAM,YAAY,GAAI;oBACvB,cAAc;uBACX;oBACH,cAAc,YAAY;;;;;YAKlC,aAAa,KAAK,IAAK,SAAS,KAAK,IAAK,YAAY;;YAEtD,IAAK,KAAK,QAAQ,aAAa,GAAI;;gBAE/B,aAAa,WAAY,WAAW,QAAS,KAAK,QAAQ;;;YAG9D,IAAK,eAAe,OAAQ;;gBAExB,KAAK,YAAY,KAAK,SAAU;mBAC7B,IAAK,CAAC,MAAO,aAAe;;gBAE/B,KAAK,QAAQ,cAAe;gBAC5B,IAAK,CAAC,OAAO,SAAU;oBACnB,OAAO;;;;;;;;;QASnB,SAAS,OAAQ,OAAQ;YACrB,IAAK,SAAU;;gBAEX,eAAgB;;;gBAGhB,OAAO;;;gBAGP,IAAK,CAAC,OAAO,SAAU;oBACnB,OAAO;;;;;;QAMnB,OAAO,OAAQ,YAAY;YACvB,OAAO,KAAK,QAAQ;WACrB,UAAW,OAAQ;YAClB,OAAQ;;;QAGZ,OAAO,OAAQ,YAAY;YACvB,OAAO,KAAK;WACb,YAAY;YACX,OAAQ,KAAK,QAAQ;WACtB;;;QAGH;;;QAGA,KAAK,KAAK,GAAI,YAAY,YAAY;YAClC,OAAO,MAAM,OAAQ,OAAO,MAAM,QAAS,OAAQ;YACnD,UAAU;;;;QAId,OAAO;YACH,OAAQ,SAAA,MAAW,IAAK;gBACpB,IAAK,CAAC,OAAO,UAAW;oBACpB,IAAK,QAAQ,UAAW,GAAG,gBAAkB;wBACzC,OAAO,aAAc,GAAG,cAAe,GAAI,cAAe,CAAE;2BACzD;wBACH,OAAO,aAAc,KAAM,CAAE;;oBAEjC,OAAO,UAAU;oBACjB,OAAO,QAAS;oBAChB,KAAK;;;YAGb,UAAW,SAAA,WAAY;gBACnB,IAAI,QAAQ,OAAO,aAAa,QAAS;gBACzC,IAAK,OAAO,WAAW,SAAS,GAAI;oBAChC,OAAO,MAAO;;;;;;;;;;;IAW9B,KAAK,cAAc,UAAW,KAAM;;QAEhC,eAAe,KAAM;;;QAGrB,IAAI,KAAK,GAAI,YAAY,YAAY;YACjC,IAAI,QAAQ,eAAe,QAAS;YACpC,IAAK,SAAS,GAAI;gBACd,eAAe,OAAQ,OAAO;;;;QAItC,OAAO;YACH,OAAQ,SAAA,MAAW,IAAK;gBACpB,IAAK,CAAC,OAAO,UAAW;oBACpB,IAAI,QAAQ;oBACZ,IAAK,IAAI,MAAM,SAAU;wBACrB,MAAM,KAAM,IAAI,MAAM;;oBAE1B,IAAK,IAAI,MAAM,UAAW;wBACtB,MAAM,KAAM,IAAI,MAAM;;oBAE1B,IAAK,QAAQ,UAAW,GAAG,gBAAkB;wBACzC,OAAO,aAAc,GAAG,cAAe,GAAI,cAAe;2BACvD;wBACH,OAAO,aAAc,KAAM;;oBAE/B,OAAO,UAAU;oBACjB,OAAO,QAAS;oBAChB,IAAI;;;;;;IAMpB,KAAK,iBAAiB,YAAA;QAatB,OAb4B,MAAK,QAAQ,YAAY;;IACrD,KAAK,oBAAoB,YAAA;QAezB,OAf+B,MAAK,QAAQ,YAAY;;;IAExD,KAAK,YAAY,YAAA;QAiBjB,OAjBuB,KAAK,QAAQ,OAAO,SAAS;;IACpD;AC1fR;;AAAA,QAAQ,OAAQ,cACX,UAAW,uDAAa,UAAW,WAAW,UAAU,cAAe;IACpE,OAAO;QACH,UAAW;QACX,YAAa;QACb,OAAQ;QACR,MAAO,SAAA,KAAW,OAAO,MAAM,MAAM,MAAO;;;;;;;;YAQxC,SAAS,eAAgB,IAAI,OAAQ;gBACjC,IAAI,WAAW,CAAC,IAAI,MAAM,aAAa;gBACvC,IAAK,KAAK,QAAQ,UAAW;oBACzB,YAAY,GAAG,UAAU,GAAG,QAAS,OAAQ,QAAQ,GAAG;uBACrD;oBACH,YAAY,GAAG,UAAU,GAAG,QAAS,OAAQ,QAAQ,GAAG;;gBAE5D,OAAO;;;;;;;;YAQX,SAAS,aAAc,MAAO;gBAC1B,IAAI,SAAS,KAAK,QAAQ,WAAW,KAAM,GAAI,YAAY,KAAM,GAAI;gBACrE,OAAO,SAAS,MAAM,aAAa;;;;YAIvC,KAAK,QAAS,SAAU,0BAA0B,aAAa,gBAAgB,gBAAgB,aAAa,cAAc,aAAa,aAAa,gBAAgB,iBAAiB,aAAa,cAAc,8CAAgD;;;;;;YAMhQ,MAAM,aAAa,YAAY;;gBAE3B,IAAI,SAAS,KAAK,QAAQ,WAAW,KAAM,GAAI,YAAY,KAAM,GAAI;;gBAErE,IAAK,KAAM,GAAI,cAAe;;oBAE1B,UAAU,KAAK,QAAQ,WAAW,KAAM,GAAI,aAAa,YAAY,KAAM,GAAI,aAAa;;;gBAGhG,OAAO;oBACH,YAAa,KAAK,QAAQ,WAAW,KAAM,GAAI,eAAe,KAAM,GAAI;oBACxE,cAAe;;;;;;;;YAQvB,MAAM,UAAU,UAAW,IAAK;;gBAE5B,IAAI,QAAQ;gBACZ,IAAK,GAAG,eAAgB;oBACpB,QAAQ,GAAG,cAAe,GAAI;;;;gBAIlC,IAAK,QAAQ,QAAS,MAAM,aAAc,WAAa,MAAM,aAAc,OAAQ,SAAS,GAAI;oBAC5F,IAAI,YAAY,eAAgB,IAAI;oBACpC,MAAM,aAAc,SAAU,MAAM,aAAc,OAAQ,IAAK,UAAW,MAAO;wBAC7E,OAAO,aAAc,KAAK,QAAS;;uBAEpC;oBACH,MAAM,aAAc,SAAU,CAAE;;;;gBAIpC,MAAM,OAAQ;;;;;;;YAOlB,MAAM,SAAS,UAAW,IAAK;;gBAE3B,IAAI,aAAa,MAAM;;gBAEvB,QAAQ,QAAS,MAAM,cAAc,UAAW,OAAO,OAAQ;oBAC3D,IAAK,MAAM,aAAc,QAAU;;wBAE/B,IAAI,WAAW,eAAgB,IAAI;;wBAEnC,IAAI,eAAe,MAAM,aAAc;;wBAEvC,IAAK,CAAC,QAAQ,QAAS,QAAU;4BAC7B,QAAQ,CAAE;;;;wBAId,KAAM,IAAI,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAM;;4BAErC,IAAI,WAAW,KAAK,QAAQ,WAAW,MAAO,GAAI,KAAM,GAAI,eAAe,MAAO,GAAI,KAAM,GAAI;;4BAEhG,IAAI,MAAM;4BACV,IAAI,MAAM;;4BAEV,IAAI,CAAC,KAAK,QAAQ,YAAa;gCAC3B,IAAI,MAAM,MAAM,MAAM,QAAS,MAAO;gCACtC,IAAI,MAAM,GAAI;oCACV,MAAM,KAAK,UAAW,MAAM,MAAO,MAAM,GAAI,QAAQ;;gCAEzD,IAAI,MAAM,MAAM,MAAM,SAAS,GAAI;oCAC/B,MAAM,KAAK,UAAW,MAAM,MAAO,MAAM,GAAI,QAAQ;;;;;4BAK7D,IAAI,UAAU,KAAK,IAAK,KAAK,KAAK,IAAK,CAAE,WAAW,aAAc,KAAQ,WAAW,MAAU,WAAW,aAAa,WAAY;;;4BAGnI,IAAI,QAAQ,KAAK,eAAgB,SAAU,QAAS,KAAK,QAAQ;;;4BAGjE,MAAO,GAAI,QAAQ,cAAe;4BAClC,IAAK,CAAC,MAAM,SAAU;gCAClB,MAAM;;;;;;;;;;YAU1B,MAAM,QAAQ,UAAW,OAAQ;;gBAE7B,IAAI,QAAQ,MAAM,aAAc,UAAW;gBAC3C,IAAI,QAAQ,MAAM,aAAa,QAAS;oBACpC,OAAO,MAAM,aAAc;;;gBAG/B,IAAK,CAAC,QAAQ,QAAS,QAAU;oBAC7B,QAAQ,CAAE;;;gBAGd,QAAQ,QAAS,OAAO,UAAW,MAAO;;oBAEtC,KAAK;;;gBAGT,IAAK,MAAM,aAAa,WAAW,GAAI;;oBAEnC,MAAM,UAAU;;;;YAIxB,MAAM,WAAW,YAAW;gBACxB,MAAM;;;YAGV,IAAI,WAAU,cAAc,MAAM;;;YAGlC,IAAI,aAAa,CAAE,aAAa;YAChC,IAAI,eAAe,CAAE,eAAe;YACpC,IAAI,YAAY,CAAE,WAAW;;YAE7B,IAAK,OAAO,cAAe;;gBAEvB,aAAa,CAAE;gBACf,eAAe,CAAE;gBACjB,YAAY,CAAE;mBACX,IAAK,OAAO,UAAU,kBAAmB;;gBAE5C,aAAa,CAAE;gBACf,eAAe,CAAE;gBACjB,YAAY,CAAE;;;;YAIlB,QAAQ,QAAS,YAAY,UAAW,OAAQ;gBAC5C,UAAU,KAAM,QAAQ,UAAU,UAAW,IAAK;oBAC9C,IAAK,MAAM,SAAU;;wBAEjB,GAAG;wBACH,GAAG;wBACH,MAAM,OAAQ;;;;;;YAM1B,QAAQ,QAAS,aAAa,OAAQ,YAAa,UAAW,OAAQ;gBAClE,UAAU,KAAM,QAAQ,UAAU,UAAW,IAAK;oBAC9C,IAAK,MAAM,SAAU;;;;wBAIjB,IAAK,GAAG,gBAAiB;4BACrB,KAAM,IAAI,IAAI,GAAG,IAAI,GAAG,eAAe,QAAQ,KAAM;gCACjD,MAAM,MAAO,GAAG,eAAgB,GAAI;;+BAErC;4BACH,MAAM,MAAO;;;;;;;YAO7B,MAAM,OAAQ,YAAY;gBACtB,OAAO,MAAM,MAAO,KAAK;eAC1B,UAAW,UAAW;;gBAErB,MAAM,WAAW,QAAQ,UAAW,aAAc;;;gBAGlD,IAAK,MAAM,UAAW;oBAClB,KAAK,SAAU;uBACZ;oBACH,KAAK,YAAa;;;gBAGtB,IAAK,MAAM,SAAU;;oBAEjB,QAAQ,QAAS,MAAM,aAAa,QAAQ,UAAW,OAAQ;wBAC3D,MAAM,MAAO;;;;;;YAMzB,KAAK,SAAU,WAAW,UAAW,SAAU;gBAC3C,IAAI,CAAC,KAAK,aAAc;oBACpB,UAAU,QAAQ,UAAW,WAAY,WAAY,WAAY;oBACjE,MAAM,UAAU,MAAO,WAAY,IAAI;oBACvC,MAAM;;;YAGd,KAAK,SAAU,SAAS,UAAW,OAAQ;gBACvC,IAAI,CAAC,KAAK,aAAc;oBACpB,QAAQ,QAAQ,UAAW,SAAU,WAAY,SAAU;oBAC3D,MAAM,QAAQ,MAAO,SAAU,IAAI;oBACnC,MAAM;;;YAGd,MAAM,OAAQ,YAAY;gBACtB,OAAO,MAAM,MAAO,KAAK;eAC1B,UAAW,MAAO;gBACjB,KAAK,UAAU,QAAQ,OAAQ,IAAI,KAAK,gBAAgB,QAAQ,UAAW,SAAU,QAAQ,SAAU,QAAS,OAAO;gBACvH,KAAK,QAAQ,OAAO,KAAM,UAAE,GAAG,GAAC;oBAEhC,OAFsC,IAAI;;gBAC1C,IAAI,KAAK,aAAc;oBACnB,MAAM,QAAQ,KAAK,QAAQ,OAAQ;oBACnC,MAAM,UAAU,KAAK,QAAQ,OAAQ,KAAK,QAAQ,OAAO,SAAS;;gBAEtE,IAAK,KAAK,QAAQ,UAAW;oBACzB,KAAK,SAAU,uBAAwB,YAAa;uBACjD;oBACH,KAAK,SAAU,yBAA0B,YAAa;;eAE3D;;YAEH,MAAM,IAAK,oBAAoB,MAAM;;YAErC,MAAM,IAAK,YAAY,YAAW;gBAC9B,UAAU,IAAK;;;;IAI3B;AChRR;;AAAA,QAAQ,OAAQ,cACX,UAAW,wCAAiB,UAAW,QAAQ,UAAW;IACvD,OAAO;QACH,UAAW;QACX,SAAU,CAAE,cAAc;QAC1B,OAAQ;QACR,SAAU,SAAA,QAAW,MAAM,MAAO;;YAE9B,IAAK,QAAQ,YAAa,KAAK,UAAY;gBACvC,MAAM;;;YAGV,OAAO,UAAW,OAAO,MAAM,MAAM,OAAQ;;gBAEzC,IAAI,eAAe,MAAO;gBAC1B,IAAI,cAAc,MAAO;;;gBAGzB,MAAM,UAAU;;;;;;gBAMhB,SAAS,YAAa,OAAQ;oBAC1B,OAAQ,KAAK,SAAU,OAAQ,MAAM,QAAQ,SAAS,WAAY;oBAClE,IAAK,CAAC,MAAM,SAAU;wBAClB,MAAM;;;;;;;;gBAQd,SAAS,WAAY,OAAQ;;oBAEzB,KAAK,IAAK,aAAa,QAAQ,WAAW,QAAQ,QAAQ,aAAa,eAAgB,OAAO,QAAS;;;;gBAI3G,IAAI,OAAO,aAAa,aAAc;oBAClC,SAAU;oBACV,MAAO;oBACP,UAAW,SAAA,SAAW,OAAQ;;;wBAE1B,YAAa;wBACb,WAAY;;;wBAGZ,MAAM,aAAa;;oBAGvB,SAAU,SAAA,UAAY;;wBAClB,KAAK,SAAU;;oBAEnB,OAAQ,SAAA,QAAY;;wBAChB,KAAK,YAAa;;;;;gBAK1B,MAAM,OAAQ,YAAY;oBACtB,OAAO,MAAM,MAAO,KAAK;mBAC1B,UAAW,UAAW;;oBAErB,MAAM,UAAU,CAAC;;;oBAGjB,IAAK,UAAW;wBACZ,KAAK,SAAU;2BACZ;wBACH,KAAK,YAAa;;;;oBAItB,MAAM,WAAW,KAAK;;;;gBAI1B,IAAI,SAAS,CAAE,aAAa;gBAC5B,IAAK,OAAO,cAAe;;oBAEvB,SAAS,CAAE;uBACR,IAAK,OAAO,UAAU,kBAAmB;;oBAE5C,SAAS,CAAE;;;;gBAIf,QAAQ,QAAS,QAAQ,UAAW,OAAQ;oBACxC,KAAK,KAAM,OAAO,UAAW,IAAK;wBAC9B,GAAG;wBACH,GAAG;wBACH,KAAK,MAAO;;;;gBAIpB,SAAU,YAAW;oBACjB,WAAY,MAAM;;;;;IAKlC","file":"drg-slider.js","sourcesContent":["/**\n * angular-slider\n * @version 1.0.0-alpha.1\n * @copyright Derek Gould 2015\n * @license MIT\n */\nangular.module('drg.slider', []);\n","angular.module( 'drg.slider' )\n    .directive( 'drgSliderBar', function () {\n        return {\n            restrict : 'EA',\n            require : '^drgSlider',\n            compile : function ( elem, attr ) {\n                return function ( scope, elem, attr, ngSliderCtrl ) {\n                    // set up the defaults\n                    scope.low = 0;\n                    scope.high = 0;\n                    scope.lowKnob = null;\n                    scope.highKnob = null;\n\n                    /**\n                     * keep the bar the correct size\n                     */\n                    function updateBar() {\n                        // get the bar's offset\n                        var offset = ngSliderCtrl.valueToPercent( scope.low, scope.lowKnob ? scope.lowKnob.elem : null, true );\n\n                        // compute the size of the bar\n                        var size = ngSliderCtrl.valueToPercent( scope.high, scope.highKnob ? scope.highKnob.elem : null, true ) - offset;\n\n                        // set the CSS\n                        if( ngSliderCtrl.options.vertical ) {\n                            elem.css( {\n                                top : offset + '%',\n                                height : size + '%'\n                            } );\n                        } else {\n                            elem.css( {\n                                left : offset + '%',\n                                width : size + '%'\n                            } );\n                        }\n                    }\n\n                    // register this bar with the slider\n                    var bar = ngSliderCtrl.registerBar( {\n                        elem : elem,\n                        scope : scope,\n                        onStart : function () {\n                            elem.addClass( 'active' );\n                        },\n                        onChange : function () {\n                            updateBar();\n                        },\n                        onEnd : function () {\n                            elem.removeClass( 'active' );\n                        }\n                    } );\n\n                    // watch the attributes for updates\n                    attr.$observe( 'low', function ( low ) {\n                        scope.low = low;\n                        updateBar();\n                    } );\n                    attr.$observe( 'high', function ( high ) {\n                        scope.high = high;\n                        updateBar();\n                    } );\n\n                    // set the default events\n                    var events = [ 'mousedown', 'touchstart' ];\n                    if ( window.PointerEvent ) {\n                        // the browser supports javascript Pointer Events (currently only IE11), use those\n                        events = [ 'pointerdown' ];\n                    } else if ( window.navigator.MSPointerEnabled ) {\n                        // the browser supports M$'s javascript Pointer Events (IE10), use those\n                        events = [ 'MSPointerDown' ]\n                    }\n\n                    // bind the start events\n                    angular.forEach( events, function ( event ) {\n                        elem.bind( event, function ( ev ) {\n                            ev.preventDefault();\n                            ev.stopPropagation();\n                            bar.start( ev );\n                        } );\n                    } );\n                }\n            }\n        }\n    } );","angular.module( 'drg.slider' )\n    .controller( 'SliderCtrl', function ( $scope, $timeout ) {\n\n        var SPACING_EQUAL = 'equal';\n        var SPACING_RELATIVE = 'relative';\n\n        // keep track of the registered knobs\n        $scope.knobs = [];\n\n        // keep track of the bars that have been created\n        $scope.bars = [];\n\n        // store the bars registered\n        var registeredBars = [];\n\n        // we'll use this to tell which knob is currently being moved\n        $scope.currentKnobs = [];\n        $scope.startOffsets = [];\n        $scope.sliding = false;\n\n        // set the default options\n        this.defaultOptions = {\n            precision : 0,\n            buffer : 0,\n            steps : 0,\n            values : [],\n            spacing : SPACING_RELATIVE, // how to space the notches on the slider \"relative\" or \"equal\"\n            continuous : false,\n            vertical : false\n        };\n        // reference the options locally to avoid any scoping issues\n        this.options = this.defaultOptions;\n\n        var ctrl = this;\n\n        function knobSort( a, b ) {\n            var a_val = a.ngModel.$modelValue;\n            var b_val = b.ngModel.$modelValue;\n            return a_val > b_val ? 1 : (b_val > a_val ? -1 : 0);\n        }\n\n        function sortKnobs() {\n            $scope.knobs.sort( knobSort );\n        }\n\n        /**\n         * Sort the knobs by model value\n         */\n        function updateKnobs() {\n            sortKnobs();\n            angular.forEach( $scope.knobs, function ( knob ) {\n                knob.ngModel.$modelValue = Math.max( $scope.floor, Math.min( knob.ngModel.$modelValue, $scope.ceiling ) );\n            } );\n        }\n\n        /**\n         * Add a bar\n         */\n        function addBar() {\n            $scope.bars.push( {\n                low : function () {\n                    return 0;\n                },\n                high : function () {\n                    return 0;\n                }\n            } );\n        }\n\n        /**\n         * Remove a bar\n         */\n        function removeBar() {\n            $scope.bars.splice( 0, 1 );\n        }\n\n        /**\n         * Make sure the correct number of bars exist and all have the right data\n         */\n        function updateBars() {\n            // get the knob count\n            var numKnobs = $scope.knobs.length;\n\n            // add bars so we have one more bar than knobs\n            while ( $scope.bars.length < numKnobs + 1 ) {\n                addBar();\n            }\n\n            // remove bars so we have one more bar than knobs\n            while ( $scope.bars.length > numKnobs + 1 ) {\n                removeBar();\n            }\n\n            /**\n             * Isolate the index from the for loop below so the low value is always correct\n             * @param index {number}\n             * @returns {Function}\n             */\n            function lowFn( index ) {\n                /**\n                 * Get the low value for the bar\n                 * @returns {number}\n                 */\n                return function () {\n                    return index > 0 ? $scope.knobs[ index - 1 ].ngModel.$modelValue : $scope.floor;\n                }\n            }\n\n            /**\n             * Isolate the index from the for loop below so the high value is always correct\n             * @param index {number}\n             * @returns {Function}\n             */\n            function highFn( index ) {\n                /**\n                 * Get the high value for the bar\n                 * @returns {number}\n                 */\n                return function () {\n                    return index < $scope.knobs.length ? $scope.knobs[ index ].ngModel.$modelValue : $scope.ceiling;\n                }\n            }\n\n            // update the low and high values for the bars\n            angular.forEach( $scope.bars, function ( bar, b ) {\n                bar.low = lowFn( b );\n                bar.high = highFn( b );\n            } );\n\n            // update the knobs and fire the change callback for all registered bars\n            angular.forEach( registeredBars, function ( bar, index ) {\n                bar.scope.lowKnob = index > 0 ? $scope.knobs[ index - 1 ] : null;\n                bar.scope.highKnob = index < $scope.knobs.length ? $scope.knobs[ index ] : null;\n                bar.onChange && bar.onChange();\n            } );\n        }\n\n        var fixDebounce;\n\n        /**\n         * Call this to refresh the slider\n         */\n        $scope.fix = function () {\n            $timeout.cancel( fixDebounce );\n            fixDebounce = $timeout( function() {\n                updateKnobs();\n                updateBars();\n            }, 25 );\n        };\n\n        /**\n         * Find the nearest value in the list of values\n         * @param position {number}\n         * @param [floor] {number}\n         * @param [ceiling] {number}\n         * @param [isValue] {boolean}\n         * @param [values] {number[]}\n         * @returns {number|undefined}\n         */\n        function nearestValue( position, floor=$scope.floor, ceiling=$scope.ceiling, isValue=false, values=ctrl.options.values ) {\n            if( ctrl.isEqualSpacing() && !isValue ) {\n                // using equal spacing strategy\n                var percent = ( position - $scope.floor ) / ( $scope.ceiling - $scope.floor );\n                var index = Math.round( percent * ( values.length - 1 ) );\n\n                while( index >= 0 && index < values.length ) {\n                    if( values[ index ] < floor ) {\n                        if( values[ index + 1 ] > ceiling ) {\n                            console.warn( 'Raise your roof!', position, values[ index ], values[ index + 1 ], ceiling );\n                            return undefined;\n                        }\n                        index++;\n                    } else if( values[ index ] > ceiling ) {\n                        if( values[ index - 1 ] < floor ) {\n                            console.warn( 'You\\'re giving me vertigo!', position, values[ index - 1 ], values[ index ], floor );\n                            return undefined;\n                        }\n                        index--;\n                    } else {\n                        return values[ index ];\n                    }\n                }\n\n                console.warn( 'I don\\'t fit anywhere :(', position, $scope.knobs.map( knob => knob.ngModel.$modelValue ), values, floor, ceiling );\n                return undefined;\n            }\n\n            // using relative spacing strategy\n            for( var i = 0; i < values.length - 1; i++ ) {\n                // find where the value fits in\n                if( position >= values[ i ] && position <= values[ i + 1 ]  ) {\n                    if( values[ i ] < floor && values[ i + 1 ] > ceiling ) {\n                        console.warn( 'BOONDOGGLE!', position, values[ i ], values[ i + 1 ], floor, ceiling );\n                        return undefined;\n                    } else if( values[ i ] < floor ) {\n                        return values[ i + 1 ];\n                    } else if( values[ i + 1 ] > ceiling ) {\n                        return values[ i ];\n                    }\n\n                    // and return the nearest value\n                    return values[ i + Math.round( ( position - values[ i ] ) / ( values[ i + 1 ] - values[ i ] ) ) ];\n                }\n            }\n\n            if( values[ values.length - 1 ] > ceiling ) {\n                console.warn( 'Tsk tsk!', position, values[ values.length - 1 ], ceiling );\n                return undefined;\n            }\n            // the value doesn't fit anywhere so just return the max value\n            return values[ values.length - 1 ];\n        }\n\n        /**\n         * Convert a value to the correct percentage for display purposes\n         * @param value {number}\n         * @param knob {angular.element}\n         * @param bar {boolean}\n         * @returns {number}\n         */\n        this.valueToPercent = function ( value, knob, bar ) {\n            // default the knob to a size of 0\n            var knobSize = 0;\n\n            if ( knob ) {\n                // we've been given a knob, get the size\n                knobSize = this.options.vertical ? knob[ 0 ].offsetHeight : knob[ 0 ].offsetWidth;\n            }\n\n            // compute the percentage size of the knob\n            var knobPercent = knobSize / $scope.dimensions().sliderSize * 100;\n\n            var percent = 1;\n\n            value = parseFloat( value );\n\n            if( ctrl.useValues() ) {\n                var values = ctrl.options.values;\n\n                for ( var i = 0; i < values.length - 1; i++ ) {\n                    // find where the value fits in\n                    if ( value >= values[ i ] && value <= values[ i + 1 ] ) {\n                        // and compute the relative percent\n                        var index = i + Math.round( ( value - values[ i ] ) / ( values[ i + 1 ] - values[ i ] ) );\n                        if( ctrl.isEqualSpacing() ) {\n                            percent = index / ( values.length - 1 );\n                        } else {\n                            percent = ( values[ index ] - $scope.floor ) / ( $scope.ceiling - $scope.floor );\n                        }\n                    }\n                }\n            } else {\n                percent = ( value - $scope.floor ) / ( $scope.ceiling - $scope.floor );\n            }\n\n            // compute the percent offset of the knob taking into account the size of the knob\n            percent = percent * ( 100 - knobPercent );\n\n            if ( bar && knob ) {\n                // we're computing this for a bar and we've been given a knob, add half of the knob back to keep the bar in the middle of the knob\n                percent += knobPercent / 2;\n            }\n\n            return percent;\n        };\n\n        /**\n         * Convert a percentage to a value\n         * @param percent {number}\n         * @param [floor] {number}\n         * @param [ceiling] {number}\n         * @returns {number}\n         */\n        this.percentToValue = function ( percent, floor=$scope.floor, ceiling=$scope.ceiling ) {\n            // compute the relative value\n            var value = ( percent * ( ceiling - floor ) ) + floor;\n\n            if( ctrl.useValues() ) {\n                // we have some specific values\n                return nearestValue( value, floor, ceiling );\n            }\n\n            // no specific values have been specified so just return the relative value\n            return value;\n        };\n\n        /**\n         * Compute the percent from the given value\n         * @param value {number}\n         * @returns {number}\n         */\n        this.toPercent = function( value ) {\n            return ( value - $scope.floor ) / ( $scope.ceiling - $scope.floor );\n        };\n\n        /**\n         * Add the knob to the slider and return some useful functions\n         * @param knob {object}\n         * @returns {{start: start, disabled: disabled}}\n         */\n        this.registerKnob = function ( knob ) {\n\n            // is this knob enabled?\n            var enabled = true;\n\n            // add the knob to the list\n            $scope.knobs.push( knob );\n            sortKnobs();\n\n            /**\n             * Normalize the value so it adheres to these criteria:\n             *    - within bounds of the slider\n             *    - if not continuous, previous and next knobs are <= or >=, respectively\n             *    - if > 1 step, falls on a step\n             *    - has the given decimal precision\n             * Then fire this knob's onChange callback if the normalized value is the same as the given value\n             * @param value {number}\n             */\n            function normalizeModel( value ) {\n                sortKnobs();\n\n                // initialize the bounds\n                var ceiling = $scope.ceiling;\n                var floor = $scope.floor;\n\n                // start with the original value\n                var normalized = parseFloat( value );\n\n                // get the index of the knob so we know the surrounding knobs\n                var index = $scope.knobs.indexOf( knob );\n\n                if ( !ctrl.options.continuous ) {\n                    // keep the knobs contained to their section of the slider\n\n                    if ( index > 0 ) {\n                        // this isn't the knob with the lowest value, set the floor to the value of the knob lower than this\n                        floor = parseFloat( $scope.knobs[ index - 1 ].ngModel.$modelValue ) + (ctrl.options.buffer > 0 ? ctrl.options.buffer : 0);\n                    }\n                    if ( index < $scope.knobs.length - 1 ) {\n                        // this isn't the knob with the highest value, set the ceiling to the value of the knob higher than this\n                        ceiling = parseFloat( $scope.knobs[ index + 1 ].ngModel.$modelValue ) - (ctrl.options.buffer > 0 ? ctrl.options.buffer : 0);\n                    }\n                }\n\n                if( ctrl.useValues() ) {\n                    // a specific set of values has been specified\n                    normalized = nearestValue( value, floor, ceiling, true );\n                } else if ( ctrl.options.steps > 1 ) {\n                    // there should be more than one step\n\n                    // get the width of a step\n                    var stepWidth = ($scope.ceiling - $scope.floor) / (ctrl.options.steps - 1);\n\n                    if ( index > 0 ) {\n                        // this isn't the knob with the lowest value, make sure the floor aligns with a step\n                        var floorMod = (floor - $scope.floor) % stepWidth;\n                        if ( floorMod > 0 ) {\n                            floor += stepWidth - floorMod;\n                        }\n                    }\n\n                    if ( index < $scope.knobs.length - 1 ) {\n                        // this isn't the knob with the highest value, make sure the ceiling aligns with a step\n                        var ceilingMod = (ceiling - $scope.floor) % stepWidth;\n                        if ( ceilingMod > 0 ) {\n                            ceiling -= ceilingMod;\n                        }\n                    }\n\n                    // align the value with a step\n                    var mod = (normalized - $scope.floor) % stepWidth;\n                    if ( mod < stepWidth / 2 ) {\n                        normalized -= mod;\n                    } else {\n                        normalized += stepWidth - mod;\n                    }\n                }\n\n                // ensure the value is within the bounds\n                normalized = Math.min( ceiling, Math.max( normalized, floor ) );\n\n                if ( ctrl.options.precision >= 0 ) {\n                    // format the value to the correct decimal precision\n                    normalized = parseFloat( normalized.toFixed( ctrl.options.precision ) );\n                }\n\n                if ( normalized === value ) {\n                    // the normalized value is the same as the original, fire the onChange callback for this knob\n                    knob.onChange && knob.onChange( value );\n                } else if ( !isNaN( normalized ) ) {\n                    // the normalized value is different than the original (an it's a number), update the model\n                    knob.ngModel.$setViewValue( normalized );\n                    if ( !$scope.$$phase ) {\n                        $scope.$apply();\n                    }\n                }\n            }\n\n            /**\n             * Do what's needed to update the DOM\n             * @param value\n             */\n            function update( value ) {\n                if ( enabled ) {\n                    // normalize\n                    normalizeModel( value );\n\n                    // fix the DOM\n                    $scope.fix();\n\n                    // make sure the changes are digested\n                    if ( !$scope.$$phase ) {\n                        $scope.$apply();\n                    }\n                }\n            }\n\n            // watch this knob's model for changes\n            $scope.$watch( function () {\n                return knob.ngModel.$modelValue;\n            }, function ( value ) {\n                update( value );\n            } );\n\n            $scope.$watch( function () {\n                return ctrl.options;\n            }, function () {\n                update( knob.ngModel.$modelValue );\n            }, true );\n\n            // initialize the bars\n            updateBars();\n\n            // listen for when this knob is removed from the DOM, remove it from the list and set to disabled\n            knob.elem.on( '$destroy', function () {\n                $scope.knobs.splice( $scope.knobs.indexOf( knob ), 1 );\n                enabled = false;\n            } );\n\n            // give the knob some useful functions\n            return {\n                start : function ( ev ) {\n                    if ( !$scope.disabled ) {\n                        if ( angular.isDefined( ev.targetTouches ) ) {\n                            $scope.currentKnobs[ ev.targetTouches[ 0 ].identifier ] = [ knob ];\n                        } else {\n                            $scope.currentKnobs[ 0 ] = [ knob ];\n                        }\n                        $scope.sliding = true;\n                        $scope.onStart( ev );\n                        knob.onStart();\n                    }\n                },\n                disabled : function () {\n                    var index = $scope.currentKnobs.indexOf( knob );\n                    if ( $scope.sliding && index >= 0 ) {\n                        $scope.onEnd( index );\n                    }\n                }\n            }\n        };\n\n        /**\n         * Add the bar to the slider\n         * @param bar {object}\n         * @return {{start: start}}\n         */\n        this.registerBar = function ( bar ) {\n            // add the bar to the list\n            registeredBars.push( bar );\n\n            // listen for when this bar is removed from the DOM and remove it from the list\n            bar.elem.on( '$destroy', function () {\n                var index = registeredBars.indexOf( bar );\n                if ( index >= 0 ) {\n                    registeredBars.splice( index, 1 );\n                }\n            } );\n\n            return {\n                start : function ( ev ) {\n                    if ( !$scope.disabled ) {\n                        var knobs = [];\n                        if ( bar.scope.lowKnob ) {\n                            knobs.push( bar.scope.lowKnob );\n                        }\n                        if ( bar.scope.highKnob ) {\n                            knobs.push( bar.scope.highKnob );\n                        }\n                        if ( angular.isDefined( ev.targetTouches ) ) {\n                            $scope.currentKnobs[ ev.targetTouches[ 0 ].identifier ] = knobs;\n                        } else {\n                            $scope.currentKnobs[ 0 ] = knobs;\n                        }\n                        $scope.sliding = true;\n                        $scope.onStart( ev );\n                        bar.onStart();\n                    }\n                }\n            }\n        };\n\n        this.isEqualSpacing = () => this.options.spacing === SPACING_EQUAL;\n        this.isRelativeSpacing = () => this.options.spacing === SPACING_RELATIVE;\n\n        this.useValues = () => ctrl.options.values.length > 1;\n    } );\n","angular.module( 'drg.slider' )\n    .directive( 'drgSlider', function ( $document, $compile, $interpolate ) {\n        return {\n            restrict : 'EA',\n            controller : 'SliderCtrl',\n            scope : true,\n            link : function ( scope, elem, attr, ctrl ) {\n\n                /**\n                 * Get the current relative position of the cursor at the given index\n                 * @param ev {Event}\n                 * @param index {number}\n                 * @returns {number}\n                 */\n                function cursorPosition( ev, index ) {\n                    var position = -1 * scope.dimensions().sliderOffset;\n                    if ( ctrl.options.vertical ) {\n                        position += ev.touches ? ev.touches[ index ].pageY : ev.pageY;\n                    } else {\n                        position += ev.touches ? ev.touches[ index ].pageX : ev.pageX;\n                    }\n                    return position;\n                }\n\n                /**\n                 * Get the current position of the given knob\n                 * @param knob {angular.element}\n                 * @returns {number}\n                 */\n                function knobPosition( knob ) {\n                    var offset = ctrl.options.vertical ? knob[ 0 ].offsetTop : knob[ 0 ].offsetLeft;\n                    return offset - scope.dimensions().sliderOffset;\n                }\n\n                // add the bars\n                elem.prepend( $compile( '<drg-slider-bar low=\"' + $interpolate.startSymbol() + ' bar.low() ' + $interpolate.endSymbol() + '\" high=\"' + $interpolate.startSymbol() + ' bar.high() ' + $interpolate.endSymbol() + '\" ng-repeat=\"bar in bars\"></ng-slider-bar>' )( scope ) );\n\n                /**\n                 * Get the current slider size and offset\n                 * @returns {{sliderSize: number, sliderOffset: number}}\n                 */\n                scope.dimensions = function () {\n                    // get the offset for the slider\n                    var offset = ctrl.options.vertical ? elem[ 0 ].offsetTop : elem[ 0 ].offsetLeft;\n\n                    if ( elem[ 0 ].offsetParent ) {\n                        // take into account the offset of this element's parent\n                        offset += ctrl.options.vertical ? elem[ 0 ].offsetParent.offsetTop : elem[ 0 ].offsetParent.offsetLeft;\n                    }\n\n                    return {\n                        sliderSize : ctrl.options.vertical ? elem[ 0 ].offsetHeight : elem[ 0 ].offsetWidth,\t// get the size of the slider\n                        sliderOffset : offset\n                    };\n                };\n\n                /**\n                 * What to do when the user starts sliding\n                 * @param ev {Event}\n                 */\n                scope.onStart = function ( ev ) {\n                    // get the index of the touch/mouse\n                    var index = 0;\n                    if ( ev.targetTouches ) {\n                        index = ev.targetTouches[ 0 ].identifier;\n                    }\n\n                    // save the starting position(s)\n                    if ( angular.isArray( scope.currentKnobs[ index ] ) && scope.currentKnobs[ index ].length > 1 ) {\n                        var cursorPos = cursorPosition( ev, index );\n                        scope.startOffsets[ index ] = scope.currentKnobs[ index ].map( function ( knob ) {\n                            return knobPosition( knob.elem ) - cursorPos;\n                        } );\n                    } else {\n                        scope.startOffsets[ index ] = [ 0 ];\n                    }\n\n                    // fire a \"move\"\n                    scope.onMove( ev );\n                };\n\n                /**\n                 * What to do when a knob is moved\n                 * @param ev {Event}\n                 */\n                scope.onMove = function ( ev ) {\n                    // get the current dimensions\n                    var dimensions = scope.dimensions();\n\n                    angular.forEach( scope.currentKnobs, function ( knobs, index ) {\n                        if ( scope.currentKnobs[ index ] ) {\n                            // get the current mouse position\n                            var position = cursorPosition( ev, index );\n\n                            var startOffsets = scope.startOffsets[ index ];\n\n                            if ( !angular.isArray( knobs ) ) {\n                                knobs = [ knobs ];\n                            }\n\n                            // get the size of the knob(s) being dragged\n                            for ( var i = 0; i < knobs.length; i++ ) {\n                                // get the size of the knob\n                                var knobSize = ctrl.options.vertical ? knobs[ i ].elem[ 0 ].offsetHeight : knobs[ i ].elem[ 0 ].offsetWidth;\n\n                                var min = 0;\n                                var max = 1;\n\n                                if( !ctrl.options.continuous ) {\n                                    var idx = scope.knobs.indexOf( knobs[ i ] );\n                                    if( idx > 0 ) {\n                                        min = ctrl.toPercent( scope.knobs[ idx - 1 ].ngModel.$modelValue );\n                                    }\n                                    if( idx < scope.knobs.length - 1 ) {\n                                        max = ctrl.toPercent( scope.knobs[ idx + 1 ].ngModel.$modelValue );\n                                    }\n                                }\n\n                                // get the current mouse/finger position as a percentage\n                                var percent = Math.max( min, Math.min( ( position + startOffsets[ i ] - ( knobSize / 2 ) ) / ( dimensions.sliderSize - knobSize ), max ) );\n\n                                // compute the value from the percentage\n                                var value = ctrl.percentToValue( percent ).toFixed( ctrl.options.precision );\n\n                                // update the model for the knob being dragged\n                                knobs[ i ].ngModel.$setViewValue( value );\n                                if ( !scope.$$phase ) {\n                                    scope.$apply();\n                                }\n                            }\n                        }\n                    } );\n                };\n\n                /**\n                 * What to do when the slide is finished\n                 */\n                scope.onEnd = function ( index ) {\n                    // remove the knob from the list of knobs currently being dragged\n                    var knobs = scope.currentKnobs[ index ] || [];\n                    if( index < scope.currentKnobs.length ) {\n                        delete scope.currentKnobs[ index ];\n                    }\n\n                    if ( !angular.isArray( knobs ) ) {\n                        knobs = [ knobs ];\n                    }\n\n                    angular.forEach( knobs, function ( knob ) {\n                        // fire the knob's onEnd callback\n                        knob.onEnd();\n                    } );\n\n                    if ( scope.currentKnobs.length === 0 ) {\n                        // we're no longer sliding\n                        scope.sliding = false;\n                    }\n                };\n\n                scope.onResize = function() {\n                    scope.fix();\n                };\n\n                var sliderId ='.drslider' + scope.$id;\n\n                // set the default events\n                var moveEvents = [ 'mousemove', 'touchmove' ];\n                var cancelEvents = [ 'mousecancel', 'touchcancel' ];\n                var endEvents = [ 'mouseup', 'touchend' ];\n\n                if ( window.PointerEvent ) {\n                    // the browser supports javascript Pointer Events (currently only IE11), use those\n                    moveEvents = [ 'pointermove' ];\n                    cancelEvents = [ 'pointercancel' ];\n                    endEvents = [ 'pointerup' ];\n                } else if ( window.navigator.msPointerEnabled ) {\n                    // the browser supports M$'s javascript Pointer Events (IE10), use those\n                    moveEvents = [ 'MSPointerMove' ];\n                    cancelEvents = [ 'MSPointerCancel' ];\n                    endEvents = [ 'MSPointerUp' ];\n                }\n\n                // bind the move events\n                angular.forEach( moveEvents, function ( event ) {\n                    $document.bind( event + sliderId, function ( ev ) {\n                        if ( scope.sliding ) {\n                            // they see me slidin', they hatin'\n                            ev.preventDefault();\n                            ev.stopPropagation();\n                            scope.onMove( ev );\n                        }\n                    } );\n                } );\n\n                // bind the end and cancel events\n                angular.forEach( cancelEvents.concat( endEvents ), function ( event ) {\n                    $document.bind( event + sliderId, function ( ev ) {\n                        if ( scope.sliding ) {\n                            // it's electric, boogie woogie, woogie\n\n                            // fire the end events for the drags that are ending\n                            if ( ev.changedTouches ) {\n                                for ( var i = 0; i < ev.changedTouches.length; i++ ) {\n                                    scope.onEnd( ev.changedTouches[ i ].identifier );\n                                }\n                            } else {\n                                scope.onEnd( 0 );\n                            }\n                        }\n                    } );\n                } );\n\n                // watch for disabilities\n                scope.$watch( function () {\n                    return scope.$eval( attr.ngDisabled );\n                }, function ( disabled ) {\n                    // do we have disabilities?\n                    scope.disabled = angular.isDefined( disabled ) && disabled;\n\n                    // tell the DOM\n                    if ( scope.disabled ) {\n                        elem.addClass( 'disabled' );\n                    } else {\n                        elem.removeClass( 'disabled' );\n                    }\n\n                    if ( scope.sliding ) {\n                        // I wanna wake up where you are, I won't say anything at all\n                        angular.forEach( scope.currentKnobs.keys(), function ( index ) {\n                            scope.onEnd( index );\n                        } );\n                    }\n                } );\n\n                // watch the attributes and update as necessary\n                attr.$observe( 'ceiling', function ( ceiling ) {\n                    if( !ctrl.useValues() ) {\n                        ceiling = angular.isDefined( ceiling ) ? parseFloat( ceiling ) : 0;\n                        scope.ceiling = isNaN( ceiling ) ? 0 : ceiling;\n                        scope.onResize();\n                    }\n                } );\n                attr.$observe( 'floor', function ( floor ) {\n                    if( !ctrl.useValues() ) {\n                        floor = angular.isDefined( floor ) ? parseFloat( floor ) : 0;\n                        scope.floor = isNaN( floor ) ? 0 : floor;\n                        scope.onResize();\n                    }\n                } );\n                scope.$watch( function () {\n                    return scope.$eval( attr.drgSliderOptions );\n                }, function ( opts ) {\n                    ctrl.options = angular.extend( {}, ctrl.defaultOptions, angular.isDefined( opts ) && angular.isObject( opts ) ? opts : {} );\n                    ctrl.options.values.sort( ( a, b ) => a - b );\n                    if( ctrl.useValues() ) {\n                        scope.floor = ctrl.options.values[ 0 ];\n                        scope.ceiling = ctrl.options.values[ ctrl.options.values.length - 1 ];\n                    }\n                    if ( ctrl.options.vertical ) {\n                        elem.addClass( 'drg-slider-vertical' ).removeClass( 'drg-slider-horizontal' );\n                    } else {\n                        elem.addClass( 'drg-slider-horizontal' ).removeClass( 'drg-slider-vertical' );\n                    }\n                }, true );\n\n                scope.$on( 'drgSlider.resize', scope.onResize );\n\n                scope.$on( '$destroy', function() {\n                    $document.off( sliderId );\n                } );\n            }\n        };\n    } );\n","angular.module( 'drg.slider' )\n    .directive( 'drgSliderKnob', function ( $parse, $timeout ) {\n        return {\n            restrict : 'EA',\n            require : [ '^drgSlider', '^ngModel' ],\n            scope : true,\n            compile : function ( elem, attr ) {\n                // make sure we have a model\n                if ( angular.isUndefined( attr.ngModel ) ) {\n                    throw \"ngSliderKnob Error: ngModel not specified\";\n                }\n\n                return function ( scope, elem, attr, ctrls ) {\n                    // get the controllers\n                    var ngSliderCtrl = ctrls[ 0 ];\n                    var ngModelCtrl = ctrls[ 1 ];\n\n                    // is the knob enabled?\n                    scope.enabled = true;\n\n                    /**\n                     * Make sure the value gets applied up the hierarchy\n                     * @param value {number}\n                     */\n                    function updateModel( value ) {\n                        $parse( attr.ngModel ).assign( scope.$parent.$parent, parseFloat( value ) );\n                        if ( !scope.$$phase ) {\n                            scope.$apply();\n                        }\n                    }\n\n                    /**\n                     * Move the knob to the correct position\n                     * @param value\n                     */\n                    function updateKnob( value ) {\n                        // set the CSS as needed\n                        elem.css( ngSliderCtrl.options.vertical ? 'top' : 'left', ngSliderCtrl.valueToPercent( value, elem ) + '%' );\n                    }\n\n                    // register the knob\n                    var knob = ngSliderCtrl.registerKnob( {\n                        ngModel : ngModelCtrl,\t\t\t// the model\n                        elem : elem,\t\t\t\t\t\t// the knob DOM element\n                        onChange : function ( value ) {\t\t// what to do when the model changes\n                            // sync the model\n                            updateModel( value );\n                            updateKnob( value );\n\n                            // expose the value to the scope\n                            scope.$viewValue = value;\n\n                        },\n                        onStart : function () {\t\t\t// what to do when the user starts dragging this knob\n                            elem.addClass( 'active' );\n                        },\n                        onEnd : function () {\t\t\t\t// what to do when the user stops dragging this knob\n                            elem.removeClass( 'active' );\n                        }\n                    } );\n\n                    // watch for disabilities\n                    scope.$watch( function () {\n                        return scope.$eval( attr.ngDisabled );\n                    }, function ( disabled ) {\n                        // is the knob disabled?\n                        scope.enabled = !disabled;\n\n                        // tell the DOM\n                        if ( disabled ) {\n                            elem.addClass( 'disabled' );\n                        } else {\n                            elem.removeClass( 'disabled' );\n                        }\n\n                        // tell the slider this knob is disabled\n                        scope.enabled || knob.disabled()\n                    } );\n\n                    // set the default events\n                    var events = [ 'mousedown', 'touchstart' ];\n                    if ( window.PointerEvent ) {\n                        // the browser supports javascript Pointer Events (currently only IE11), use those\n                        events = [ 'pointerdown' ];\n                    } else if ( window.navigator.MSPointerEnabled ) {\n                        // the browser supports M$'s javascript Pointer Events (IE10), use those\n                        events = [ 'MSPointerDown' ]\n                    }\n\n                    // bind the start events\n                    angular.forEach( events, function ( event ) {\n                        elem.bind( event, function ( ev ) {\n                            ev.preventDefault();\n                            ev.stopPropagation();\n                            knob.start( ev );\n                        } );\n                    } );\n\n                    $timeout( function() {\n                        updateKnob( scope.$viewValue );\n                    } );\n                };\n            }\n        }\n    } );\n"],"sourceRoot":"/source/"}